.env
----
# Schoology Co-Pilot Configuration

# --- Authentication ---
# Full session cookie string extracted directly from your provided network request log.
OLD_SCHOOLOGY_COOKIE="s_stats_browser_info=%7B%22pluginInfo%22%3A%7B%22pdf%22%3A%5B%22pdf%22%2C%22application/pdf%22%2C%221%22%5D%2C%22quicktime%22%3A%5B%22qt%22%2C%22video/quicktime%22%2C%220%22%5D%2C%22realplayer%22%3A%5B%22realp%22%2C%22audio/x-pn-realaudio-plugin%22%2C%220%22%5D%2C%22wma%22%3A%5B%22wma%22%2C%22application/x-mplayer2%22%2C%220%22%5D%2C%22director%22%3A%5B%22dir%22%2C%22application/x-director%22%2C%220%22%5D%2C%22flash%22%3A%5B%22fla%22%2C%22application/x-shockwave-flash%22%2C%220%22%5D%2C%22java%22%3A%5B%22java%22%2C%22application/x-java-vm%22%2C%220%22%5D%2C%22gears%22%3A%5B%22gears%22%2C%22application/x-googlegears%22%2C%220%22%5D%2C%22silverlight%22%3A%5B%22ag%22%2C%22application/x-silverlight%22%2C%220%22%5D%7D%2C%22res%22%3A%221710x1112%22%7D; apt.uid=AP-IBYB1G3SIPA6-2-1759590066364-73921151.0.2.2249589b-9e64-489d-b3c6-4a45306f0912; has_js=1; cbLDB=1; SESS203b9bead5ca8f4fbb607005f50a33ad=6f3823c5497bb99fa272a6abc8791465; apt.sid=AP-IBYB1G3SIPA6-2-1759893165423-56892569"

SCHOOLOGY_COOKIE="apt.uid=AP-IBYB1G3SIPA6-2-1759590066364-73921151.0.2.2249589b-9e64-489d-b3c6-4a45306f0912; _gcl_au=1.1.327145066.1759925919; _ga=GA1.1.1696360727.1759925919; _fbp=fb.1.1759925919402.830911096779083779; _ga_TZBJ5BZWDC=GS2.1.s1759925919$o1$g1$t1759925993$j60$l0$h0; s_stats_browser_info=%7B%22pluginInfo%22%3A%7B%22pdf%22%3A%5B%22pdf%22%2C%22application/pdf%22%2C%221%22%5D%2C%22quicktime%22%3A%5B%22qt%22%2C%22video/quicktime%22%2C%220%22%5D%2C%22realplayer%22%3A%5B%22realp%22%2C%22audio/x-pn-realaudio-plugin%22%2C%220%22%5D%2C%22wma%22%3A%5B%22wma%22%2C%22application/x-mplayer2%22%2C%220%22%5D%2C%22director%22%3A%5B%22dir%22%2C%22application/x-director%22%2C%220%22%5D%2C%22flash%22%3A%5B%22fla%22%2C%22application/x-shockwave-flash%22%2C%220%22%5D%2C%22java%22%3A%5B%22java%22%2C%22application/x-java-vm%22%2C%220%22%5D%2C%22gears%22%3A%5B%22gears%22%2C%22application/x-googlegears%22%2C%220%22%5D%2C%22silverlight%22%3A%5B%22ag%22%2C%22application/x-silverlight%22%2C%220%22%5D%7D%2C%22res%22%3A%221710x1112%22%7D; has_js=1; SESS203b9bead5ca8f4fbb607005f50a33ad=2d1a667d6283d286f7871184848f7359; cbLDB=1; apt.sid=AP-IBYB1G3SIPA6-2-1760544200321-92543786"
# Your Schoology user ID, extracted from the calendar URL.
SCHOOLOGY_USER_ID="105724617"

# Comma-separated list of your course IDs, extracted from the URLs provided.
SCHOOLOGY_COURSE_IDS="7890186853,7890186902,7890186797,7890186817,7890186659,7890656563"

# --- Server Configuration ---
# Host on 0.0.0.0 to be accessible from your router's port forwarding.
APP_HOST="0.0.0.0"

# Port your router is forwarding to on this machine.
APP_PORT="5544"


WIDGET_BASE_URL="https://smooth-content-porpoise.ngrok-free.app/widget"


______________


.env.test
----
# Schoology Co-Pilot Configuration

# --- Authentication ---
# Full session cookie string extracted directly from your provided network request log.
OLD_SCHOOLOGY_COOKIE="s_stats_browser_info=%7B%22pluginInfo%22%3A%7B%22pdf%22%3A%5B%22pdf%22%2C%22application/pdf%22%2C%221%22%5D%2C%22quicktime%22%3A%5B%22qt%22%2C%22video/quicktime%22%2C%220%22%5D%2C%22realplayer%22%3A%5B%22realp%22%2C%22audio/x-pn-realaudio-plugin%22%2C%220%22%5D%2C%22wma%22%3A%5B%22wma%22%2C%22application/x-mplayer2%22%2C%220%22%5D%2C%22director%22%3A%5B%22dir%22%2C%22application/x-director%22%2C%220%22%5D%2C%22flash%22%3A%5B%22fla%22%2C%22application/x-shockwave-flash%22%2C%220%22%5D%2C%22java%22%3A%5B%22java%22%2C%22application/x-java-vm%22%2C%220%22%5D%2C%22gears%22%3A%5B%22gears%22%2C%22application/x-googlegears%22%2C%220%22%5D%2C%22silverlight%22%3A%5B%22ag%22%2C%22application/x-silverlight%22%2C%220%22%5D%7D%2C%22res%22%3A%221710x1112%22%7D; apt.uid=AP-IBYB1G3SIPA6-2-1759590066364-73921151.0.2.2249589b-9e64-489d-b3c6-4a45306f0912; has_js=1; cbLDB=1; SESS203b9bead5ca8f4fbb607005f50a33ad=6f3823c5497bb99fa272a6abc8791465; apt.sid=AP-IBYB1G3SIPA6-2-1759893165423-56892569"

SCHOOLOGY_COOKIE="s_stats_browser_info=%7B%22pluginInfo%22%3A%7B%22pdf%22%3A%5B%22pdf%22%2C%22application/pdf%22%2C%221%22%5D%2C%22quicktime%22%3A%5B%22qt%22%2C%22video/quicktime%22%2C%220%22%5D%2C%22realplayer%22%3A%5B%22realp%22%2C%22audio/x-pn-realaudio-plugin%22%2C%220%22%5D%2C%22wma%22%3A%5B%22wma%22%2C%22application/x-mplayer2%22%2C%220%22%5D%2C%22director%22%3A%5B%22dir%22%2C%22application/x-director%22%2C%220%22%5D%2C%22flash%22%3A%5B%22fla%22%2C%22application/x-shockwave-flash%22%2C%220%22%5D%2C%22java%22%3A%5B%22java%22%2C%22application/x-java-vm%22%2C%220%22%5D%2C%22gears%22%3A%5B%22gears%22%2C%22application/x-googlegears%22%2C%220%22%5D%2C%22silverlight%22%3A%5B%22ag%22%2C%22application/x-silverlight%22%2C%220%22%5D%7D%2C%22res%22%3A%221710x1112%22%7D; apt.uid=AP-IBYB1G3SIPA6-2-1759590066364-73921151.0.2.2249589b-9e4-489d-b3c6-4a45306f0912; _gcl_au=1.1.327145066.1759925919; _ga=GA1.1.1696360727.1759925919; _fbp=fb.1.1759925919402.830911096779083779; _ga_TZBJ5BZWDC=GS2.1.s1759925919$o1$g1$t1759925993$j60$l0$h0; SESS203b9bead5ca8f4fbb607005f50a33ad=e6f7545e29b61e075d8a1775279de3e8; has_js=1; cbLDB=1; apt.sid=AP-IBYB1G3SIPA6-2-1760045188011-24362626"
# --- Identifiers ---
# Your Schoology user ID, extracted from the calendar URL.
SCHOOLOGY_USER_ID="105724617"

# Comma-separated list of your course IDs, extracted from the URLs provided.
SCHOOLOGY_COURSE_IDS="7890186853,7890186902,7890186797,7890186817,7890186659,7890656563"

# --- Server Configuration ---
# Host on 0.0.0.0 to be accessible from your router's port forwarding.
APP_HOST="0.0.0.0"

# Port your router is forwarding to on this machine.
APP_PORT="5544"

______________


PROJECT.md
----
# `PROJECT.md`

## Project Name: Schoology Co-Pilot

### 1. Project Goal

To create a conversational agent within ChatGPT that provides a unified, proactive interface to a student's Schoology data. This project will be implemented as a single, self-contained Python application running locally on a desktop PC. It will handle data fetching, storage, and serving requests from the OpenAI Apps SDK via the Model Context Protocol (MCP).

### 2. Core Architecture

The application consists of three primary, concurrently operating components:

1.  **Data Synchronizer:** A background scheduler (`apscheduler`) that periodically fetches data from Schoology's internal web APIs, creating a complete local mirror.
2.  **Local Data Mirror:** A single-file SQLite database (`schoology.db`) that stores a structured, clean, and *semantically indexed* version of the fetched data, including full course material hierarchies. SQLAlchemy will be used as the ORM.
3.  **MCP Server:** A FastAPI application running on Uvicorn that exposes a `/mcp` endpoint. It serves near-instantaneous responses to ChatGPT by querying the local SQLite database.

### 3. Tech Stack

*   **Backend Framework:** FastAPI with Uvicorn
*   **Web Client:** `requests`
*   **HTML Parsing:** `beautifulsoup4` (Critical for updates and course materials)
*   **Scheduling:** `apscheduler`
*   **Database/ORM:** SQLite with SQLAlchemy
*   **Configuration:** `python-dotenv`
*   **Frontend (UI Component):** React (using the official **Inline HTML Serving Pattern** for portability)

### 4. Project Structure (No Change Needed Here)

```
schoology-copilot/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ crud.py         # Data access functions (Create, Read, Update).
â”‚   â”‚   â”œâ”€â”€ database.py     # SQLAlchemy engine and session management.
â”‚   â”‚   â””â”€â”€ models.py       # SQLAlchemy ORM models (tables).
â”‚   â”œâ”€â”€ mcp_server/
â”‚   â”‚   â”œâ”€â”€ server.py       # FastAPI app definition and /mcp route.
â”‚   â”‚   â””â”€â”€ tools.py        # Logic for each MCP tool (e.g., briefing.get).
â”‚   â”œâ”€â”€ scheduler/
â”‚   â”‚   â”œâ”€â”€ scheduler.py    # APScheduler initialization and management.
â”‚   â”‚   â””â”€â”€ sync_job.py     # The main synchronization task function.
â”‚   â””â”€â”€ schoology_client/
â”‚       â””â”€â”€ client.py       # Class-based client for making requests to Schoology.
â”œâ”€â”€ web/                      # React frontend components (handled separately).
â”œâ”€â”€ main.py                   # Main application entry point.
â”œâ”€â”€ schoology.db              # Local SQLite database file.
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .env
â””â”€â”€ .gitignore
```

### 5. Implementation Details & Data Flow (Revised)

#### **Step 1: Configuration (`.env`)**

*   Authentication with Schoology will be handled via a session cookie.
*   The `.env` file must contain:
    *   `SCHOOLOGY_COOKIE`: The full cookie string copied from a logged-in browser session.
    *   `SCHOOLOGY_USER_ID`: The user's unique ID found in Schoology URLs.
    *   `SCHOOLOGY_COURSE_IDS`: A comma-separated list of numeric course IDs for targeted synchronization.

#### **Step 2: Schoology Client (`app/schoology_client/client.py`)**

*   A `SchoologyClient` class will encapsulate all web requests.
*   It must implement methods to fetch key data points:
    *   `get_calendar_events(start_ts, end_ts)`: Fetches calendar items (assignments/events).
    *   `get_feed_updates()`: Fetches recent activity/announcements feed (requires HTML parsing).
    *   `get_course_materials(course_id)`: **(NEW)** Fetches all materials (files, links, folders) for a specific course page (requires extensive HTML parsing to extract hierarchy and links).
    *   `get_grades(course_id)`: (Endpoint to be discovered) Fetches grades for a specific course.

#### **Step 3: Database Models (`app/database/models.py`)**

*   Define SQLAlchemy ORM models, including new models for state and resources:
    *   **`Assignment` Model:** (Existing) For calendar assignments.
    *   **`Event` Model:** (Existing) For calendar events.
    *   **`Update` Model:** (Existing) For feed posts/announcements.
    *   **`Resource` Model:** **(NEW)** To store all course materials (title, URL, type, course ID, folder/unit).
    *   **`UserState` Model:** **(NEW)** To store non-academic user state, such as `last_seen_updates_utc` for tracking unread announcements.
    *   **`Grade` Model:** (Existing) For grade tracking.

#### **Step 4: Data Synchronization (`app/scheduler/sync_job.py`)**

*   The `sync_schoology_data()` function is the core cron job.
*   It performs a complete, multi-step sync and upsert:
    1.  Sync Calendar Events.
    2.  Sync Feed Updates.
    3.  **Sync Course Materials:** Loops through all `SCHOOLOGY_COURSE_IDS`, calls `client.get_course_materials()`, and performs a structured upsert into the `Resource` table.

#### **Step 5: MCP Server (`app/mcp_server/`)**

*   The `server.py` file defines the FastAPI application and handles the JSON-RPC routing.
*   The `tools.py` file implements the core logic, using the local database exclusively for speed.
*   **New Tool:** `resources.get_all(course_name)`: Queries the `Resource` table and returns a dense, structured JSON payload (a "Context Dump") containing all materials for the specified course. **This tool returns no UI.**
*   **New Tool:** `updates.get_new()`: Queries the `Update` table relative to the user's `UserState.last_seen_updates_utc` and returns a text summary, updating the timestamp afterward.

#### **Step 6: Main Entry Point (`main.py`)**

*   This script ties everything together: loading config, initializing the database, starting the background scheduler, and running the FastAPI/MCP server.

______________


README.md
----
# Schoology Co-Pilot

A conversational agent that transforms the fragmented Schoology platform into a unified, proactive assistant for students within ChatGPT.

## Quick Start

### 1. Install Dependencies

```bash
pip install -r requirements.txt
```

### 2. Configure Environment

Copy the `.env` file and fill in your Schoology credentials:

```bash
cp .env .env.local
# Edit .env.local with your actual values
```

Required environment variables:
- `SCHOOLOGY_COOKIE`: Your session cookie from a logged-in browser
- `SCHOOLOGY_USER_ID`: Your user ID (found in Schoology URLs)
- `SCHOOLOGY_COURSE_IDS`: Comma-separated list of course IDs to monitor

### 3. Seed Sample Data (Optional)

For testing purposes, you can add sample assignments:

```bash
python seed_data.py
```

### 4. Run the Application

```bash
python main.py
```

The MCP server runs at `http://<APP_HOST>:<APP_PORT>` (defaults in `.env`).
Example with your `.env`: `http://0.0.0.0:5544`

## Project Structure

```
schoology-copilot/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ database/          # SQLAlchemy models and database setup
â”‚   â”œâ”€â”€ mcp_server/        # FastAPI MCP server and tools
â”‚   â”œâ”€â”€ scheduler/         # Background data synchronization
â”‚   â””â”€â”€ schoology_client/  # Schoology API client
â”œâ”€â”€ web/                   # React frontend (future)
â”œâ”€â”€ main.py               # Application entry point
â”œâ”€â”€ seed_data.py          # Sample data seeder
â””â”€â”€ requirements.txt      # Python dependencies
```

## Features

### Current (Stub Implementation)
- **System Ping**: Basic connectivity test
- **Daily Briefing**: Shows upcoming assignments (with sample data)

### Planned
- **Performance Dashboard**: Grade tracking and trends
- **Interactive Planner**: Kanban-style task management
- **Proactive Alerts**: Real-time notifications for new grades/assignments

## Development

The application consists of three main components:

1. **Data Synchronizer**: Background scheduler that fetches data from Schoology
2. **Local Data Mirror**: SQLite database storing structured data
3. **MCP Server**: FastAPI server exposing tools to ChatGPT

## API Endpoints

- `GET /healthz` - Health check
- `POST /mcp` - MCP protocol endpoint (JSON-RPC 2.0)

## MCP Tools (JSON-RPC 2.0)
**List tools**
```bash
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":1,"method":"list_tools"}'
```
**Call `system.ping`**
```bash
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":2,"method":"call_tool","params":{"name":"system.ping"}}'
```
**Call `briefing.get`**
```bash
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":3,"method":"call_tool","params":{"name":"briefing.get","args":{"range":"48h"}}}'
```

## Next Steps

1. Implement real Schoology API endpoints in `SchoologyClient`
2. Add grade tracking and performance dashboard
3. Build interactive planner with Kanban board
4. Create React frontend components
5. Add real-time notifications and alerts

______________


VISION.md
----
# `VISION.md`

## Project: Schoology Co-Pilot

### High-Level Vision

The Schoology Co-Pilot is a conversational agent, built on the OpenAI Apps SDK, that transforms the fragmented and noisy Schoology platform into a unified, proactive, and actionable assistant for students. It eliminates the cognitive load of navigating countless pages and feeds by synthesizing all critical academic and campus life information into a single, intelligent dialogue within ChatGPT.

### The Problem with the Current State

Schoology serves as a digital repository but forces the student to be a reactive information hunter. The core pain points are:

*   **Information Silos:** Critical data is scattered across a dozen separate Course and Group pages, with no single source of truth.
*   **Signal vs. Noise:** The main feed is a chronological firehose where urgent deadlines, new grades, and low-priority announcements have the same visual weight.
*   **Reactive Workflow:** The student must manually and repeatedly pull information, check for updates, and synthesize connections in their own mind.

### The Co-Pilot Vision

The Schoology Co-Pilot will be an intelligent partner that manages the logistics of student life, allowing the student to focus on learning and participation. It will provide:

*   A **unified view** of all courses, groups, grades, and deadlines.
*   **Proactive insights** that surface what's important, right now.
*   **Intelligent Context Dumps** to the LLM, enabling semantic search and powerful reasoning over all course materials.

It moves the user from being an "information puller" to a "decision maker."

---

## Core Features (Revised)

### 1. The Daily Briefing (Assignments & Events)

*   **Description:** This is the cornerstone feature, providing a complete, prioritized summary of upcoming academic deadlines and campus life events.
*   **Interaction:** The user prompts, "What's my daily briefing?" The Co-Pilot responds with a rich, interactive component that displays:
    *   **High-Priority Tasks:** Assignments and assessments due within the next 24-48 hours.
    *   **Upcoming Events:** A unified calendar view of class events, club meetings, and school-wide deadlines.
*   **Example Prompts:**
    *   `"What's my briefing?"`
    *   `"What do I need to worry about today?"`

### 2. The Universal Resource Finder (LLM-Native Search)

*   **Description:** This feature replaces manual clicking through course folders. The Co-Pilot provides the LLM with a complete, structured context of all course materials (links, files, assignments, notes), allowing the AI to perform a semantic search and reasoning based on content and intent.
*   **Interaction:** The user asks a question about a resource. The Co-Pilot calls a "context dump" tool, which returns the entire course material structure. The LLM then reasons over this data and returns the correct link and context.
*   **Example Prompts:**
    *   `"Where is the syllabus for AP English?"`
    *   `"Find the PDF about the derivative in my Calculus class."`
    *   `"What resources do I have for the Hamlet unit?"`

### 3. The Intelligent Update Digest

*   **Description:** This solves the "Signal vs. Noise" problem by synthesizing the Schoology feed and prioritizing announcements from teachers and administrators over social chatter. It tracks which updates have been seen to provide a true "What's New" experience.
*   **Interaction:** The user asks, "Any new announcements?" The Co-Pilot queries its stateful mirror and returns only the posts received since the last interaction, often summarizing the most important items.
*   **Example Prompts:**
    *   `"What are the key announcements today?"`
    *   `"Any updates from the US Student Notices group?"`

### 4. The Performance Dashboard (Future)

*   **Description:** Transforms reactive grade checking into a proactive and insightful experience by tracking grade changes and providing performance context.
*   **Interaction:** The user asks, "How are my grades?". The Co-Pilot renders an interactive component showing new grade alerts, class averages, and performance trends (`â†‘` or `â†“`).

---



______________


WIDGET_SETUP.md
----
# Widget Setup Guide

## Overview

Your Schoology Co-Pilot widget has been simplified to use the **CDN pattern** instead of inline HTML. This approach is more reliable and easier to debug.

## How It Works

1. **Widget HTML Shell**: The widget serves a simple HTML shell that loads your React app from `localhost:8080`
2. **Asset Server**: A separate Python script serves your built React assets
3. **MCP Integration**: ChatGPT loads the widget and fetches data from your MCP server

## Setup Instructions

### Step 1: Build Your React Widget

```bash
cd web/briefing-widget
npm run build
```

### Step 2: Start the Widget Asset Server

In a separate terminal:

```bash
# From the project root
python serve_widget.py
```

This will serve your built React app on `http://localhost:8080`

### Step 3: Start Your MCP Server

In another terminal:

```bash
# From the project root
python main.py
```

### Step 4: Test the Widget

Your widget should now be accessible through ChatGPT. The widget will:
- Load the HTML shell from your MCP server
- Fetch React assets from `localhost:8080`
- Display your interactive briefing widget

## File Changes Made

### `app/mcp_server/resources.py`
- âœ… Simplified to use CDN pattern
- âœ… Removed complex inline HTML generation
- âœ… Uses simple HTML shell that loads from localhost:8080

### `app/mcp_server/tools.py`
- âœ… Updated to use proper widget metadata
- âœ… Added embedded resource support
- âœ… Simplified tool response format

### `app/mcp_server/server.py`
- âœ… Removed SSE endpoints (not needed)
- âœ… Simplified JSON-RPC handling
- âœ… Cleaner, more maintainable code

## Troubleshooting

### Widget Not Loading?
1. Make sure `serve_widget.py` is running on port 8080
2. Check that `web/briefing-widget/dist` exists
3. Verify your React build completed successfully

### CORS Issues?
The widget server includes CORS headers for ChatGPT compatibility.

### Port Conflicts?
If port 8080 is in use, you can modify the port in both:
- `serve_widget.py` (line with `PORT = 8080`)
- `app/mcp_server/resources.py` (the localhost URLs)

## Benefits of This Approach

1. **Reliability**: No more complex file reading and inlining
2. **Debugging**: Easy to inspect network requests in browser dev tools
3. **Development**: Hot reload works with your React dev server
4. **Maintainability**: Cleaner separation of concerns

## Next Steps

1. Test the widget through ChatGPT
2. Verify data loading and display works correctly
3. Customize the React widget as needed
4. Deploy both servers when ready for production



______________


build-and-run.sh
----
#!/bin/bash

set -e  # Exit on any error

echo "ðŸš€ Building and Starting Schoology Co-Pilot"
echo ""

# Build the widget
echo "ðŸ“¦ Building React widget..."
cd web/briefing-widget
npm run build
cd ../..

echo "âœ… Widget built successfully"
echo ""
echo "ðŸŒ Starting MCP server (serves widget at /widget)..."
echo ""
python main.py

______________


main.py
----
# main.py

import uvicorn
import os
import logging
from app.mcp_server.server import app

def main():
    """Main entry point to run the application."""
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - [%(threadName)s] - %(message)s'
    )

    # Get host and port from environment, with defaults
    # Note: load_dotenv() is now called inside the lifespan manager
    host = os.getenv("APP_HOST", "0.0.0.0")
    port = int(os.getenv("APP_PORT", "5544")) # Default to your port
    
    logging.info(f"ðŸš€ Starting Uvicorn server process on http://{host}:{port}")
    # Run the FastAPI app using uvicorn
    # The 'app' object now contains the lifespan logic
    uvicorn.run(app, host=host, port=port)

if __name__ == "__main__":
    main()

______________


requirements.txt
----
fastapi>=0.115
uvicorn[standard]>=0.30
SQLAlchemy>=2.0
python-dotenv>=1.0
APScheduler>=3.10
requests>=2.32
beautifulsoup4>=4.12
bleach>=6.1
pydantic>=2.7
mcp>=1.0.0
aiofiles>=23.0.0

______________


seed_data.py
----
#!/usr/bin/env python3
"""
Quick seeder script to add sample data for testing.
Run this once to populate the database with sample assignments.
"""

from app.database.database import SessionLocal, init_db
from app.database.models import Assignment
from datetime import datetime, timedelta, timezone

def seed_sample_data():
    """Add sample assignments to the database for testing."""
    init_db()
    db = SessionLocal()
    
    try:
        # Add a few sample assignments
        sample_assignments = [
            Assignment(
                id=1001, 
                course_id=1, 
                course_name="AP Calculus", 
                title="Homework 1: Limits and Continuity",
                due_at_utc=datetime.now(timezone.utc) + timedelta(hours=12), 
                url="https://example.com/calc-hw1"
            ),
            Assignment(
                id=1002, 
                course_id=2, 
                course_name="AP Physics", 
                title="Lab Report: Projectile Motion",
                due_at_utc=datetime.now(timezone.utc) + timedelta(hours=36), 
                url="https://example.com/physics-lab1"
            ),
            Assignment(
                id=1003, 
                course_id=3, 
                course_name="English Literature", 
                title="Essay: Analysis of 'The Great Gatsby'",
                due_at_utc=datetime.now(timezone.utc) + timedelta(days=3), 
                url="https://example.com/english-essay1"
            ),
        ]
        
        for assignment in sample_assignments:
            db.add(assignment)
        
        db.commit()
        print(f"âœ… Added {len(sample_assignments)} sample assignments to the database")
        
    except Exception as e:
        db.rollback()
        print(f"âŒ Error seeding data: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    seed_sample_data()


______________


serve_widget.py
----
#!/usr/bin/env python3
"""
Simple static file server for the widget assets.
Run this script to serve your built React widget on localhost:8080
"""

import http.server
import socketserver
import os
import sys
from pathlib import Path

def main():
    # Check if dist folder exists
    dist_path = Path("web/briefing-widget/dist")
    if not dist_path.exists():
        print("âŒ Error: dist folder not found at web/briefing-widget/dist")
        print("Please run: cd web/briefing-widget && npm run build")
        sys.exit(1)
    
    # Change to dist directory
    os.chdir(dist_path)
    
    PORT = 8080
    
    class Handler(http.server.SimpleHTTPRequestHandler):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, directory=str(dist_path), **kwargs)
        
        def end_headers(self):
            # Add CORS headers for ChatGPT
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
            self.send_header('Access-Control-Allow-Headers', 'Content-Type')
            super().end_headers()
    
    with socketserver.TCPServer(("", PORT), Handler) as httpd:
        print(f"ðŸš€ Widget server running at http://localhost:{PORT}")
        print(f"ðŸ“ Serving files from: {dist_path.absolute()}")
        print("Press Ctrl+C to stop")
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            print("\nðŸ‘‹ Widget server stopped")

if __name__ == "__main__":
    main()



______________


start.sh
----
#!/bin/bash

echo "ðŸš€ Starting Schoology Co-Pilot"
echo ""

# Build the widget
echo "ðŸ“¦ Building widget..."
cd web/briefing-widget
npm run build
cd ../..

# Start the widget server in background
echo "ðŸŒ Starting widget server on :8080..."
python3 web/briefing-widget/serve.py &
WIDGET_PID=$!

# Wait for server to start
sleep 2

echo ""
echo "âœ… Widget server running on http://localhost:8080"
echo ""
echo "ðŸ“ In another terminal, run:"
echo "   ngrok start --all"
echo ""
echo "Then get your widget URL from ngrok dashboard and update .env:"
echo "   WIDGET_BASE_URL=\"https://your-widget-tunnel.ngrok-free.app\""
echo ""
echo "Finally, start the MCP server in a third terminal:"
echo "   python main.py"
echo ""
echo "Press Ctrl+C to stop widget server"

# Wait for interrupt
trap "kill $WIDGET_PID; exit" INT
wait

______________


test_client.py
----
# test_client.py

import os
from dotenv import load_dotenv
from datetime import datetime, timedelta, timezone
from app.schoology_client.client import SchoologyClient

def test_calendar_fetch():
    """
    Loads environment variables and fetches calendar events for the next 30 days.
    """
    # Load .env file from the project root
    print("Loading environment variables...")
    load_dotenv()

    # Check if credentials are loaded
    cookie = os.getenv("SCHOOLOGY_COOKIE")
    user_id = os.getenv("SCHOOLOGY_USER_ID")
    if not cookie or not user_id:
        print("âŒ ERROR: SCHOOLOGY_COOKIE and SCHOOLOGY_USER_ID must be set in your .env file.")
        return

    print("Credentials loaded. Initializing Schoology Client...")
    client = SchoologyClient()

    # Define the time range: from now to 30 days from now
    now = datetime.now(timezone.utc)
    end_date = now + timedelta(days=30)
    
    start_timestamp = int(now.timestamp())
    end_timestamp = int(end_date.timestamp())

    print(f"\nFetching events from {now.isoformat()} to {end_date.isoformat()}...")
    events = client.get_calendar_events(start_ts=start_timestamp, end_ts=end_timestamp)

    if not events:
        print("\nâŒ No events returned. Check the following:")
        print("   1. Is your SCHOOLOGY_COOKIE valid and not expired?")
        print("   2. Is the SCHOOLOGY_USER_ID correct?")
        print("   3. Is there an issue with the constructed URL or network connectivity?")
        return

    print(f"\nâœ… Successfully fetched {len(events)} events!")
    print("--- Sample Events ---")
    
    for i, event in enumerate(events[:5]): # Print the first 5 events
        event_type = event.get('e_type', 'N/A')
        title = event.get('titleText', 'No Title')
        source = event.get('content_title', 'N/A')
        start_time = event.get('start', 'N/A')
        
        print(f"\nEvent {i+1}:")
        print(f"  Title: {title}")
        print(f"  Type: {event_type}")
        print(f"  Source: {source}")
        print(f"  Start Time: {start_time}")
    
    print("\n--- End of Sample ---")


if __name__ == "__main__":
    test_calendar_fetch()

______________


test_mcp.py
----
#!/usr/bin/env python3
"""
Test script for MCP methods
"""
import requests
import json

BASE_URL = "http://127.0.0.1:5544/mcp"

def test_mcp_method(method, params=None):
    """Test an MCP method"""
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": method
    }
    if params:
        payload["params"] = params
    
    try:
        response = requests.post(BASE_URL, json=payload, headers={"Content-Type": "application/json"})
        print(f"\n=== Testing {method} ===")
        print(f"Request: {json.dumps(payload, indent=2)}")
        print(f"Response: {json.dumps(response.json(), indent=2)}")
        return response.json()
    except Exception as e:
        print(f"Error testing {method}: {e}")
        return None

if __name__ == "__main__":
    print("Testing MCP methods...")
    
    # Test initialize
    test_mcp_method("initialize", {
        "protocolVersion": "2024-11-05",
        "capabilities": {},
        "clientInfo": {"name": "test-client", "version": "1.0"}
    })
    
    # Test tools/list
    test_mcp_method("tools/list")
    
    # Test tools/call
    test_mcp_method("tools/call", {
        "name": "briefing.get",
        "arguments": {"range": "48h"}
    })
    
    # Test legacy methods for backward compatibility
    test_mcp_method("list_tools")
    test_mcp_method("call_tool", {
        "name": "briefing.get",
        "args": {"range": "48h"}
    })


______________


test_mcp_curl.sh
----
#!/bin/bash
# Test script for MCP methods using curl

echo "Testing MCP methods with curl..."

echo -e "\n=== Testing initialize ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"curl","version":"1"}}}' | jq .

echo -e "\n=== Testing tools/list ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":2,"method":"tools/list"}' | jq .

echo -e "\n=== Testing tools/call (briefing.get) ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"briefing.get","arguments":{"range":"48h"}}}' | jq .

echo -e "\n=== Testing legacy list_tools ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":4,"method":"list_tools"}' | jq .

echo -e "\n=== Testing legacy call_tool ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":5,"method":"call_tool","params":{"name":"briefing.get","args":{"range":"48h"}}}' | jq .


______________


app/__init__.py
----


______________


app/mcp_server/__init__.py
----


______________


app/mcp_server/resources.py
----
# app/mcp_server/resources.py

import os
import logging
from pathlib import Path

MIME_TYPE = "text/html+skybridge"
WIDGET_URI = "ui://widget/briefing.html"

# Store asset content in memory to avoid reading from disk on every request
_WIDGET_HTML_CACHE = None

def get_widget_html() -> str:
    """
    Reads the built React JS and CSS from the /dist folder and injects
    them into an HTML shell. This is the "inline" pattern from the official docs.
    """
    global _WIDGET_HTML_CACHE
    if _WIDGET_HTML_CACHE:
        return _WIDGET_HTML_CACHE

    try:
        # Find the path to the 'dist' directory relative to this file
        dist_path = Path(__file__).parent.parent.parent / "web" / "briefing-widget" / "dist"
        
        # Find the specific JS and CSS files Vite generates (they have hashes)
        assets_path = dist_path / "assets"
        # Use next() with a generator expression to find the first match
        js_file = next(assets_path.glob("index-*.js"))
        css_file = next(assets_path.glob("index-*.css"))

        js_content = js_file.read_text()
        css_content = css_file.read_text()
        
        html = f"""
<div id="root"></div>
<style>{css_content}</style>
<script type="module">{js_content}</script>
        """.strip()

        _WIDGET_HTML_CACHE = html
        logging.info(f"âœ… Successfully loaded and cached widget assets from {dist_path}")
        return html

    except (FileNotFoundError, StopIteration) as e:
        error_msg = "FATAL: Widget asset files not found. Did you run 'npm run build' in /web/briefing-widget?"
        logging.error(f"{error_msg} - {e}")
        return f"""<div style="font-family: sans-serif; padding: 2em; color: red;">
                       <h2>Widget Error</h2><p>{error_msg}</p>
                   </div>"""

def list_resources() -> list[dict]:
    """Return list of resource definitions as dicts."""
    return [{
        "uri": WIDGET_URI,
        "mimeType": MIME_TYPE,
        "name": "Daily Briefing Widget",
        "description": "Interactive daily briefing with assignments"
    }]

def read_resource(uri: str) -> dict | None:
    """Read a resource and return its contents."""
    if uri != WIDGET_URI:
        return None
    
    return {
        "contents": [{
            "uri": WIDGET_URI,
            "mimeType": MIME_TYPE,
            "text": get_widget_html(),
        }]
    }

______________


app/mcp_server/server.py
----
from fastapi import FastAPI, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from sqlalchemy.orm import Session
from contextlib import asynccontextmanager
from dotenv import load_dotenv
import os
import mcp.types as types
import logging

from app.database.database import get_db, init_db
from app.scheduler.scheduler import start_scheduler, stop_scheduler
from app.mcp_server import tools, resources

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("ðŸš€ Starting up...")
    load_dotenv()
    init_db()
    start_scheduler()
    yield
    print("ðŸ‘‹ Shutting down...")
    stop_scheduler()

app = FastAPI(title="Schoology Co-Pilot", lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

widget_dist_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'web', 'briefing-widget', 'dist'))
if os.path.exists(widget_dist_path):
    app.mount("/widget", StaticFiles(directory=widget_dist_path, html=True), name="widget")
    logging.info(f"âœ… Widget assets mounted at /widget from {widget_dist_path}")
else:
    logging.error(f"âŒ Widget 'dist' folder not found at {widget_dist_path}")
    logging.error("   Please run: cd web/briefing-widget && npm run build")

@app.get("/healthz")
def health():
    return {"ok": True}

def json_rpc_response(request_id, result=None, error=None):
    """Helper to build JSON-RPC 2.0 responses."""
    resp = {"jsonrpc": "2.0", "id": request_id}
    if error:
        resp["error"] = error
    else:
        resp["result"] = result
    return resp

def serialize_mcp_result(result):
    """Convert MCP types to JSON-serializable dicts."""
    if isinstance(result, types.CallToolResult):
        return {
            "content": [
                {"type": c.type, "text": c.text}
                for c in result.content
            ],
            "structuredContent": result.structuredContent,
            "isError": result.isError,
            "_meta": result.meta
        }
    return result

@app.get("/mcp")
async def mcp_get_handler():
    """
    Handles GET requests to the MCP endpoint, typically from health checks.
    Returns a simple 200 OK response.
    """
    return {
        "status": "ok",
        "message": "MCP server is running. Use POST for JSON-RPC requests."
    }

@app.post("/mcp")
async def mcp_endpoint(request: Request, db: Session = Depends(get_db)):
    """
    Handles POST requests to the MCP endpoint for the main JSON-RPC protocol.
    """
    try:
        body = await request.json()
    except:
        return json_rpc_response(None, error={"code": -32700, "message": "Parse error"})

    method = body.get("method")
    req_id = body.get("id", -1)
    params = body.get("params", {})

    try:
        if method == "initialize":
            return json_rpc_response(req_id, {
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}, "resources": {}},
                "serverInfo": {"name": "schoology-copilot", "version": "0.1.0"}
            })
        
        elif method in ("tools/list", "list_tools"):
            tool_dicts = tools.list_tools()
            return json_rpc_response(req_id, {"tools": tool_dicts})
        
        elif method in ("tools/call", "call_tool"):
            name = params.get("name")
            args = params.get("arguments") or params.get("args", {})
            
            result_object = tools.call_tool(name, args, db)
            serialized = serialize_mcp_result(result_object)
            return json_rpc_response(req_id, serialized)
        
        elif method in ("resources/list", "list_resources"):
            return json_rpc_response(req_id, {"resources": resources.list_resources()})
        
        elif method in ("resources/read", "read_resource"):
            uri = params.get("uri")
            if not uri:
                return json_rpc_response(req_id, error={"code": -32602, "message": "Missing uri parameter"})
            result = resources.read_resource(uri)
            if result:
                return json_rpc_response(req_id, result)
            return json_rpc_response(req_id, error={"code": 1, "message": "Not found"})
        
        else:
            return json_rpc_response(req_id, error={"code": -32601, "message": f"Method not found: {method}"})

    except Exception as e:
        import traceback
        traceback.print_exc()
        return json_rpc_response(req_id, error={"code": -32603, "message": str(e)})

______________


app/mcp_server/tools.py
----
# app/mcp_server/tools.py

from datetime import datetime, timezone
from sqlalchemy.orm import Session
from typing import Any, Dict, List
import logging
from app.database import crud
import mcp.types as types
from collections import defaultdict

WIDGET_URI = "ui://widget/briefing.html"
MIME_TYPE = "text/html+skybridge"

def _tool_meta():
    """Metadata that tells ChatGPT this tool produces a widget."""
    return {
        "openai/outputTemplate": WIDGET_URI,
        "openai/toolInvocation/invoking": "Gathering your assignments...",
        "openai/toolInvocation/invoked": "Here's your briefing",
        "openai/widgetAccessible": True,
        "openai/resultCanProduceWidget": True,
        "annotations": {
            "destructiveHint": False,
            "openWorldHint": False,
            "readOnlyHint": True,
        }
    }

def _embedded_widget_resource() -> types.EmbeddedResource:
    """Returns the embedded widget resource as proper MCP type."""
    from app.mcp_server.resources import get_widget_html
    
    return types.EmbeddedResource(
        type="resource",
        resource=types.TextResourceContents(
            uri=WIDGET_URI,
            mimeType=MIME_TYPE,
            text=get_widget_html(),
            title="Daily Briefing",
        )
    )

def list_tools() -> List[Dict[str, Any]]:
    """Return list of tool definitions as dicts."""
    return [
        {
            "name": "briefing.get",
            "title": "Get Daily Briefing",
            "description": "Returns an interactive list of upcoming assignments",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "range": {
                        "type": "string",
                        "enum": ["today", "48h", "week"],
                        "default": "today",
                        "description": "Time window: 'today' (24h), '48h' (2 days), or 'week' (7 days)"
                    }
                },
                "additionalProperties": False
            },
            "_meta": _tool_meta()
        },
        # --- NEW TOOL DEFINITION ---
        {
            "name": "resources.get_all",
            "title": "Get All Course Resources",
            "description": "Performs a 'context dump' of all known materials (files, links, assignments) for a specific course, allowing the model to perform a semantic search.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "course_name": {
                        "type": "string",
                        "description": "The name of the course to fetch materials for, e.g., 'AP English' or 'Calculus'."
                    }
                },
                "required": ["course_name"],
                "additionalProperties": False
            }
            # No _meta needed as this is a headless tool
        }
    ]

def _fmt_display(dt: datetime | None) -> str:
    if not dt:
        return ""
    try:
        # Use '%-I' on Unix-like systems for non-padded hour, fallback to '%I'
        return dt.strftime("%a, %b %d @ %-I:%M %p").replace('AM', 'am').replace('PM', 'pm')
    except ValueError:
        return dt.strftime("%a, %b %d @ %I:%M %p").replace('AM', 'am').replace('PM', 'pm')

def get_assignment_type(title: str) -> str:
    """Identify assignment type from its title."""
    title_lower = title.lower()
    if "test" in title_lower:
        return "Test"
    if "quiz" in title_lower:
        return "Quiz"
    if "project" in title_lower:
        return "Project"
    if "essay" in title_lower or "paper" in title_lower:
        return "Paper"
    return "Homework"  # Default

def _call_briefing_get(args: dict, db: Session) -> types.CallToolResult:
    """Handles the logic for the briefing.get tool."""
    window = args.get("range", "today").lower().strip()
    hours_map = {"today": 24, "48h": 48, "week": 168}
    hours = hours_map.get(window, 24)
    label_map = {"today": "today", "48h": "the next 48h", "week": "the next 7 days"}
    label = label_map.get(window, "soon")
    
    assignments = crud.upcoming_assignments(db, window_hours=hours, limit=50)
    
    # Data for the UI (_meta): The full, detailed list
    ui_items = [{
        "id": a.id, "title": a.title, "course": a.course_name, "url": a.url,
        "dueAt": a.due_at_utc.isoformat() if a.due_at_utc else None,
        "dueAtDisplay": _fmt_display(a.due_at_utc),
        "type": get_assignment_type(a.title)
    } for a in assignments]
    
    # Data for the Model (structuredContent): A concise summary
    model_summary_items = [{
        "title": a.title, "course": a.course_name,
        "due": _fmt_display(a.due_at_utc)
    } for a in assignments[:5]] # Only show top 5 to the model

    # Build the final payloads
    structured = {
        "summary": {
            "count": len(assignments),
            "rangeLabel": label,
            "assignments": model_summary_items
        }
    }
    
    meta_for_ui = {
        "assignments": ui_items,
        "count": len(assignments),
        "range": window,
        "rangeLabel": label,
        "generatedAt": datetime.now(timezone.utc).isoformat()
    }
    
    widget_resource = _embedded_widget_resource()
    
    return types.CallToolResult(
        content=[types.TextContent(
            type="text",
            text=f"Found {len(assignments)} assignment(s) due {label}."
        )],
        structuredContent=structured,
        _meta={
            **_tool_meta(),
            "openai.com/widget": widget_resource.model_dump(mode="json"),
            "ui": meta_for_ui
        }
    )

def _call_resources_get_all(args: dict, db: Session) -> types.CallToolResult:
    """Handles the logic for the new resources.get_all tool."""
    course_name = args.get("course_name")
    if not course_name:
        return types.CallToolResult(
            content=[types.TextContent(type="text", text="Error: course_name is required.")],
            isError=True
        )

    resources = crud.get_resources_by_course_name(db, course_name)
    
    if not resources:
        return types.CallToolResult(
            content=[types.TextContent(type="text", text=f"I couldn't find any materials for a course named '{course_name}'. Please check the name or wait for the next sync.")]
        )
        
    # Group resources by parent folder for a structured output
    grouped_resources = defaultdict(list)
    for res in resources:
        # Use a default key for items that aren't in a specific folder
        key = res.parent_folder or "Course Materials" 
        grouped_resources[key].append({
            "title": res.title,
            "type": res.resource_type,
            "url": res.url,
        })
        
    # Create the final JSON blob for the model
    context_dump = {
        "courseName": course_name,
        "materialCount": len(resources),
        "structure": dict(grouped_resources) # Convert defaultdict to a regular dict for clean JSON
    }
    
    return types.CallToolResult(
        content=[types.TextContent(
            type="text",
            text=f"I've retrieved all {len(resources)} materials for {course_name}. I will now use this information to find the specific resource you requested."
        )],
        structuredContent=context_dump
    )

def call_tool(name: str, args: dict, db: Session) -> types.CallToolResult:
    """
    Router to execute the correct tool based on its name.
    """
    if name == "briefing.get":
        return _call_briefing_get(args, db)
    
    if name == "resources.get_all":
        return _call_resources_get_all(args, db)
    
    # Fallback for unknown tools
    return types.CallToolResult(
        content=[types.TextContent(type="text", text=f"Unknown tool: {name}")],
        isError=True
    )

______________


app/scheduler/__init__.py
----


______________


app/scheduler/scheduler.py
----
# app/scheduler/scheduler.py

from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
from sqlalchemy.orm import Session
from app.database.database import SessionLocal
from app.scheduler.sync_job import sync_schoology_data
import random
import logging
from datetime import datetime, timezone # <-- ADD THIS

_scheduler: BackgroundScheduler | None = None

def _job_wrapper():
    db: Session = SessionLocal()
    try:
        sync_schoology_data(db)
    finally:
        db.close()

def start_scheduler():
    global _scheduler
    if _scheduler:
        return _scheduler
    
    logging.info("Initializing and starting background scheduler...")
    _scheduler = BackgroundScheduler(timezone="UTC")
    # Run every 5 minutes with jitter
    _scheduler.add_job(
        _job_wrapper, 
        IntervalTrigger(minutes=5, jitter=random.randint(0, 60)),
        id="schoology_sync_job",
        replace_existing=True,
        misfire_grace_time=300 # 5 minutes grace period
    )
    _scheduler.start()
    # Trigger the first run immediately
    _scheduler.get_job('schoology_sync_job').modify(next_run_time=datetime.now(timezone.utc))
    logging.info("Scheduler started and first sync triggered.")
    return _scheduler

def stop_scheduler():
    global _scheduler
    if _scheduler and _scheduler.running:
        logging.info("Shutting down background scheduler...")
        _scheduler.shutdown()
        logging.info("Scheduler shut down.")

______________


app/scheduler/sync_job.py
----
# app/scheduler/sync_job.py

import logging
import os
from sqlalchemy.orm import Session
from app.schoology_client.client import SchoologyClient
from app.database import crud
from datetime import datetime, timedelta, timezone

def sync_schoology_data(db: Session):
    logging.info("Starting Schoology sync job...")
    client = SchoologyClient()

    try:
        # --- 1. Sync Calendar Events (Existing) ---
        now = datetime.now(timezone.utc)
        # Fetch a wide window: from 1 week ago to 60 days in the future
        start_date = now - timedelta(days=7)
        end_date = now + timedelta(days=60)
        
        start_ts = int(start_date.timestamp())
        end_ts = int(end_date.timestamp())
        
        events_data = client.get_calendar_events(start_ts=start_ts, end_ts=end_ts)
        
        if events_data:
            logging.info(f"Fetched {len(events_data)} calendar items. Upserting into database...")
            crud.upsert_calendar_events(db, events_data)
        else:
            logging.warning("No calendar items returned from Schoology client.")

        # --- 2. Sync Course Materials (New) ---
        course_ids_str = os.getenv("SCHOOLOGY_COURSE_IDS")
        if not course_ids_str:
            logging.warning("SCHOOLOGY_COURSE_IDS not set in .env. Skipping material sync.")
        else:
            course_ids = [int(cid.strip()) for cid in course_ids_str.split(',') if cid.strip()]
            logging.info(f"Found {len(course_ids)} course(s) to sync for materials.")
            
            for course_id in course_ids:
                try:
                    materials_data = client.get_course_materials(course_id)
                    if materials_data:
                        crud.upsert_resources(db, course_id, materials_data)
                    else:
                        logging.info(f"No materials found for course {course_id}. Nothing to sync.")
                except Exception as e:
                    logging.error(f"Failed to sync materials for course {course_id}: {e}", exc_info=True)
                    # Continue to the next course even if one fails
                    continue
        
        logging.info("Sync job completed successfully.")
        return {"ok": True}

    except Exception as e:
        logging.error(f"A critical error occurred during the sync job: {e}", exc_info=True)
        db.rollback() # Rollback any partial changes on error
        return {"ok": False, "error": str(e)}

______________


app/database/__init__.py
----


______________


app/database/crud.py
----
# app/database/crud.py

from sqlalchemy.orm import Session
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo
from app.database import models
import re
import logging

# ---- FIXED: Remove status filter since it's not being set by sync ----
def upcoming_assignments(db: Session, window_hours: int = 48, limit: int = 20):
    """
    Return assignments due within the next `window_hours`.
    """
    now = datetime.now(timezone.utc)
    end = now + timedelta(hours=window_hours)
    q = (
        db.query(models.Assignment)
        # REMOVED: .filter(models.Assignment.status == "open")
        .filter(models.Assignment.due_at_utc != None)  # noqa: E711
        .filter(models.Assignment.due_at_utc >= now)
        .filter(models.Assignment.due_at_utc <= end)
        .order_by(models.Assignment.due_at_utc.asc())
        .limit(limit)
    )
    return q.all()

def parse_html_title(html_title: str) -> str:
    """Extracts clean text from the Schoology HTML title."""
    if not html_title:
        return "Untitled"
    clean = re.sub('<.*?>', '', html_title)
    return clean.strip()

def parse_schoology_date(date_str: str) -> datetime | None:
    """
    Parses Schoology's 'YYYY-MM-DD HH:MM:SS' into UTC.

    CRITICAL FIX: Based on empirical testing, the Schoology calendar API
    returns a string that is already effectively UTC, despite appearing as
    local time. We treat the raw string as naive UTC time to avoid the
    incorrect UTC conversion offset.
    """
    if not date_str:
        return None
    dt_naive = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
    return dt_naive.replace(tzinfo=timezone.utc)


def upsert_calendar_events(db: Session, events: list[dict]):
    """
    Takes a list of raw event dicts from the SchoologyClient and updates or inserts
    them into the database, distinguishing between Assignments and Events.
    """
    for item in events:
        is_assignment_type = item.get('e_type') in ['assignment', 'assessment', 'common-assessment', 'discussion']
        
        if is_assignment_type:
            # FIX: Use content_id for link construction, as item['id'] is the calendar event ID
            assignment_id_for_link = item.get('content_id') 
            if not assignment_id_for_link:
                assignment_id_for_link = item['id'] 
                
            # Use the correct assignment ID and append '/info' for robust linking
            assignment_url = f"https://classes.esdallas.org/assignment/{assignment_id_for_link}/info"
            
            existing_assignment = db.query(models.Assignment).filter(models.Assignment.id == item['id']).first()
            
            if existing_assignment:
                # Update existing assignment
                existing_assignment.title = item.get('titleText', 'Untitled Assignment')
                existing_assignment.due_at_utc = parse_schoology_date(item.get('start'))
                existing_assignment.course_name = item.get('content_title', 'Unknown Course')
                existing_assignment.url = assignment_url
                existing_assignment.status = "open"  # SET STATUS HERE
                existing_assignment.last_seen_at_utc = datetime.now(timezone.utc)
            else:
                # Create new assignment
                new_assignment = models.Assignment(
                    id=item['id'],
                    title=item.get('titleText', 'Untitled Assignment'),
                    due_at_utc=parse_schoology_date(item.get('start')),
                    course_name=item.get('content_title', 'Unknown Course'),
                    url=assignment_url,
                    course_id=item.get('realm_id'),
                    status="open",  # SET STATUS HERE
                )
                db.add(new_assignment)
        else:
            # It's a generic event, handle it in the Event table
            existing_event = db.query(models.Event).filter(models.Event.id == item['id']).first()

            if existing_event:
                # Update existing event
                existing_event.title = item.get('titleText', 'Untitled Event')
                existing_event.start_utc = parse_schoology_date(item.get('start'))
                existing_event.end_utc = parse_schoology_date(item.get('end')) if item.get('has_end') == '1' else None
                existing_event.source = item.get('content_title', 'Unknown Source')
            else:
                # Create new event
                new_event = models.Event(
                    id=item['id'],
                    title=item.get('titleText', 'Untitled Event'),
                    start_utc=parse_schoology_date(item.get('start')),
                    end_utc=parse_schoology_date(item.get('end')) if item.get('has_end') == '1' else None,
                    source=item.get('content_title', 'Unknown Source'),
                )
                db.add(new_event)
                
    db.commit()

# --- NEW FUNCTION TO FETCH RESOURCES FOR A COURSE ---
def get_resources_by_course_name(db: Session, course_name: str):
    """
    Fetches all resources for a given course name, attempting a case-insensitive match.
    """
    # Use ilike for case-insensitive matching, which is more robust.
    # Find the course_id from the Assignment table first, then query resources with that ID.
    subquery = db.query(models.Assignment.course_id).filter(models.Assignment.course_name.ilike(f"%{course_name}%")).distinct()
    course_ids = [result[0] for result in subquery.all()]
    
    if not course_ids:
        return []

    return db.query(models.Resource).filter(models.Resource.course_id.in_(course_ids)).all()

# --- NEW FUNCTION TO UPSERT COURSE RESOURCES ---
def upsert_resources(db: Session, course_id: int, resources_data: list[dict]):
    """
    Takes a list of resource dicts from the SchoologyClient for a specific course
    and updates or inserts them into the Resource table.
    """
    if not resources_data:
        return

    # Process items in chunks to avoid excessively large queries
    item_urls = [item.get("url") for item in resources_data if item.get("url")]
    if not item_urls:
        return
        
    # Find existing resources in the database that match the incoming URLs for this specific course
    existing_resources_query = db.query(models.Resource).filter(
        models.Resource.course_id == course_id,
        models.Resource.url.in_(item_urls)
    )
    existing_resources_map = {res.url: res for res in existing_resources_query}

    for item in resources_data:
        item_url = item.get("url")
        if not item_url:
            continue

        existing_resource = existing_resources_map.get(item_url)
        
        if existing_resource:
            # Update existing resource if needed
            existing_resource.title = item.get("title", "Untitled Resource")
            existing_resource.resource_type = item.get("resource_type", "Unknown")
            existing_resource.parent_folder = item.get("parent_folder")
            # last_seen_at_utc is handled by onupdate in the model
        else:
            # Create a new resource since it wasn't found in our map
            new_resource = models.Resource(
                schoology_id=item.get("schoology_id"),
                course_id=course_id,
                title=item.get("title", "Untitled Resource"),
                url=item_url,
                resource_type=item.get("resource_type", "Unknown"),
                parent_folder=item.get("parent_folder"),
            )
            db.add(new_resource)
    
    db.commit()
    logging.info(f"Successfully upserted/updated {len(resources_data)} resources for course ID {course_id}.")

______________


app/database/database.py
----
from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "sqlite:///schoology.db"

engine = create_engine(
    DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)
Base = declarative_base()

def init_db():
    # pragma tuning for local SQLite
    with engine.connect() as conn:
        conn.exec_driver_sql("PRAGMA journal_mode=WAL;")
        conn.exec_driver_sql("PRAGMA synchronous=NORMAL;")
    from app.database import models  # ensure models registered
    Base.metadata.create_all(bind=engine)

# FastAPI deps pattern (used in /mcp route)
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


______________


app/database/models.py
----
# app/database/models.py

from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import String, Integer, DateTime, Text, Enum
from datetime import datetime, timezone
from app.database.database import Base

def utcnow():
    return datetime.now(timezone.utc)

class Assignment(Base):
    __tablename__ = "assignments"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    course_id: Mapped[int] = mapped_column(Integer, index=True)
    course_name: Mapped[str] = mapped_column(String(255))
    title: Mapped[str] = mapped_column(String(400))
    due_at_utc: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), index=True)
    url: Mapped[str | None] = mapped_column(String(1024))
    status: Mapped[str] = mapped_column(String(32), default="open")
    last_seen_at_utc: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=utcnow, index=True)

class Event(Base):
    __tablename__ = "events"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    title: Mapped[str] = mapped_column(String(400))
    start_utc: Mapped[datetime] = mapped_column(DateTime(timezone=True), index=True)
    end_utc: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    source: Mapped[str] = mapped_column(String(255))

class Update(Base):
    __tablename__ = "updates"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    author: Mapped[str] = mapped_column(String(255))
    content_html_sanitized: Mapped[str] = mapped_column(Text)
    posted_at_utc: Mapped[datetime] = mapped_column(DateTime(timezone=True), index=True)
    source: Mapped[str] = mapped_column(String(255))

class Grade(Base):
    __tablename__ = "grades"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    course_id: Mapped[int] = mapped_column(Integer, index=True)
    course_name: Mapped[str] = mapped_column(String(255))
    assignment_id: Mapped[int] = mapped_column(Integer, index=True)
    assignment_title: Mapped[str] = mapped_column(String(400))
    score_raw: Mapped[str | None] = mapped_column(String(64))
    score_pct: Mapped[float | None] = mapped_column()
    posted_at_utc: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=utcnow, index=True)

class PlannerTask(Base):
    __tablename__ = "planner_tasks"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    title: Mapped[str] = mapped_column(String(400))
    due_at_utc: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    origin: Mapped[str] = mapped_column(String(16), default="personal")  # 'schoology'|'personal'
    schoology_assignment_id: Mapped[int | None] = mapped_column(Integer, index=True)
    column: Mapped[str] = mapped_column(String(16), default="todo")  # 'todo','in_progress','done'
    priority: Mapped[int] = mapped_column(Integer, default=0)

# --- NEW MODEL FOR COURSE MATERIALS ---
class Resource(Base):
    __tablename__ = "resources"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    # The unique ID from Schoology, used for upserting. Can be null if not parseable.
    schoology_id: Mapped[int | None] = mapped_column(Integer, index=True)
    course_id: Mapped[int] = mapped_column(Integer, index=True)
    title: Mapped[str] = mapped_column(String(512))
    url: Mapped[str] = mapped_column(String(1024))
    resource_type: Mapped[str] = mapped_column(String(64), index=True)
    parent_folder: Mapped[str | None] = mapped_column(String(255))
    last_seen_at_utc: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=utcnow, onupdate=utcnow, index=True)

______________


app/schoology_client/__init__.py
----


______________


app/schoology_client/client.py
----
# app/schoology_client/client.py

import os
import requests
import time
import logging
import re
import random
from typing import List, Dict, Any
from bs4 import BeautifulSoup
from collections import deque # <-- NEW IMPORT

class SchoologyClient:
    def __init__(self):
        """Initializes the SchoologyClient with credentials from environment variables."""
        cookie = os.getenv("SCHOOLOGY_COOKIE")
        if not cookie:
            raise ValueError("SCHOOLOGY_COOKIE environment variable not set.")
        
        self.user_id = os.getenv("SCHOOLOGY_USER_ID")
        if not self.user_id:
            raise ValueError("SCHOOLOGY_USER_ID environment variable not set.")

        self.base_url = "https://classes.esdallas.org"
        self.s = requests.Session()
        self.s.headers.update({
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36",
            "Accept": "application/json, text/javascript, */*; q=0.01",
            "X-Requested-With": "XMLHttpRequest",
            "Cookie": cookie,
            "Referer": f"{self.base_url}/home"
        })

        # --- NEW RATE-LIMITING INSTANCE VARIABLES ---
        self.request_timestamps = deque()
        self.RATE_LIMIT_COUNT = 15
        self.RATE_LIMIT_SECONDS = 5
    
    # --- NEW RATE-LIMITING METHOD ---
    def _rate_limited_get(self, *args, **kwargs):
        """
        A wrapper for requests.get that enforces the 15 requests/5 sec rule.
        """
        now = time.monotonic()
        
        # Remove timestamps older than our time window
        while self.request_timestamps and now - self.request_timestamps[0] > self.RATE_LIMIT_SECONDS:
            self.request_timestamps.popleft()
            
        # If we have hit the request limit, calculate wait time and sleep
        if len(self.request_timestamps) >= self.RATE_LIMIT_COUNT:
            oldest_request_time = self.request_timestamps[0]
            time_since_oldest = now - oldest_request_time
            wait_time = self.RATE_LIMIT_SECONDS - time_since_oldest
            
            if wait_time > 0:
                logging.info(f"Rate limit reached. Waiting for {wait_time:.2f} seconds...")
                time.sleep(wait_time)
        
        # Make the request and record the timestamp
        response = self.s.get(*args, **kwargs)
        self.request_timestamps.append(time.monotonic())
        return response

    def _parse_material_rows(self, soup: BeautifulSoup, resource_type: str) -> List[Dict[str, Any]]:
        # ... (this method is unchanged) ...
        materials = []
        rows = soup.find_all('div', class_='filtered-view-list-row')
        for row in rows:
            try:
                title_element = row.find('div', class_='s-common-block_title').find('a')
                if not title_element: continue
                title = title_element.get_text(strip=True)
                relative_url = title_element['href']
                absolute_url = f"{self.base_url}{relative_url}"
                schoology_id_match = re.search(r'/(\d+)$', relative_url)
                if not schoology_id_match: schoology_id_match = re.search(r'/(\d+)/', relative_url)
                schoology_id = int(schoology_id_match.group(1)) if schoology_id_match else None
                parent_folder = None
                parent_folder_element = row.find('div', class_='materials-filtered-parent-folder')
                if parent_folder_element:
                    tooltip = parent_folder_element.find('span', attrs={'role': 'tooltip'})
                    if tooltip and tooltip.has_attr('aria-label'): parent_folder = tooltip['aria-label'].strip()
                materials.append({"schoology_id": schoology_id, "title": title, "url": absolute_url, "resource_type": resource_type, "parent_folder": parent_folder})
            except Exception as e:
                logging.warning(f"Could not parse a material row. Error: {e}", exc_info=True)
                continue
        return materials

    def get_course_materials(self, course_id: int) -> List[Dict[str, Any]]:
        # ... (this method is updated to use the new rate-limiter) ...
        logging.info(f"Starting material sync for course ID: {course_id}")
        all_materials = []
        filter_map = {"assignments": "Assignment", "assessments": "Assessment", "documents_files": "File", "documents_links": "Link", "discussion": "Discussion", "pages": "Page"}
        url = f"{self.base_url}/course/{course_id}/materials"
        
        for filter_name, resource_type in filter_map.items():
            params = {"list_filter": filter_name, "ajax": 1, "style": "full", "_": int(time.time() * 1000)}
            logging.info(f"Fetching '{resource_type}' materials for course {course_id}...")
            
            try:
                # --- USE THE RATE-LIMITED GETTER ---
                response = self._rate_limited_get(url, params=params)
                response.raise_for_status()
                data = response.json()
                
                if not data or not isinstance(data, dict) or not data.values():
                    logging.info(f"No content returned for filter '{filter_name}'. Skipping.")
                    continue
                
                html_content = list(data.values())[0]
                soup = BeautifulSoup(html_content, 'html.parser')
                parsed_items = self._parse_material_rows(soup, resource_type)
                if parsed_items:
                    logging.info(f"Found {len(parsed_items)} item(s) of type '{resource_type}'.")
                    all_materials.extend(parsed_items)
                
                # We no longer need the static sleep here
                # time.sleep(random.uniform(2, 4)) 

            except requests.RequestException as e:
                logging.error(f"Network error fetching materials for course {course_id} with filter {filter_name}: {e}")
            except Exception as e:
                logging.error(f"An unexpected error occurred for course {course_id} with filter {filter_name}: {e}", exc_info=True)
        
        logging.info(f"Completed material sync for course {course_id}. Found {len(all_materials)} total items.")
        return all_materials

    def get_calendar_events(self, start_ts: int, end_ts: int) -> List[Dict[str, Any]]:
        # ... (this method is updated to use the new rate-limiter) ...
        view_id = "2025-91"
        url = f"{self.base_url}/calendar/{self.user_id}/{view_id}"
        params = {"ajax": 1, "start": start_ts, "end": end_ts, "_": int(time.time() * 1000)}
        logging.info(f"ATTEMPTING TO FETCH URL: {url}")
        
        response = None 
        try:
            # --- USE THE RATE-LIMITED GETTER ---
            response = self._rate_limited_get(url, params=params)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            logging.error(f"AN EXCEPTION OCCURRED: {type(e).__name__} - {e}")
            if response is not None:
                logging.error(f"RESPONSE STATUS CODE: {response.status_code}")
                logging.error(f"--- RAW SERVER RESPONSE TEXT ---\n{response.text}\n--- END ---")
            else:
                logging.error("Request failed before a response was received.")
        return []

    # --- Stubs for future implementation ---
    def get_feed_updates(self): return []
    def get_grades(self, course_id: int): return []
    def get_course_assignments(self, course_id: int): return []

______________


web/package.json
----
{
  "name": "schoology-copilot-web",
  "private": true,
  "scripts": {
    "build": "echo \"(stub) add React build later\""
  }
}


______________


web/briefing-widget/index.html
----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Briefing Widget</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.jsx"></script>
  </body>
</html>


______________


web/briefing-widget/package.json
----
{
  "name": "briefing-widget",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "dayjs": "^1.11.10"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.2.1",
    "vite": "^5.2.0"
  }
}


______________


web/briefing-widget/serve.py
----
# app/mcp_server/server.py

from fastapi import FastAPI, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from contextlib import asynccontextmanager
from dotenv import load_dotenv
import os
import mcp.types as types
import logging

from app.database.database import get_db, init_db
from app.scheduler.scheduler import start_scheduler, stop_scheduler
from app.mcp_server import tools, resources

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("ðŸš€ Starting up...")
    load_dotenv()
    init_db()
    start_scheduler()
    yield
    print("ðŸ‘‹ Shutting down...")
    stop_scheduler()

app = FastAPI(title="Schoology Co-Pilot", lifespan=lifespan)

# CORS is still important for development and communication with ChatGPT
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/healthz")
def health():
    return {"ok": True}

def json_rpc_response(request_id, result=None, error=None):
    """Helper to build JSON-RPC 2.0 responses."""
    resp = {"jsonrpc": "2.0", "id": request_id}
    if error:
        resp["error"] = error
    else:
        resp["result"] = result
    return resp

def serialize_mcp_result(result):
    """Convert MCP types to JSON-serializable dicts."""
    if isinstance(result, types.CallToolResult):
        # The .model_dump() method handles serialization correctly
        return result.model_dump(mode="json", by_alias=True)
    return result

@app.post("/mcp")
async def mcp_endpoint(request: Request, db: Session = Depends(get_db)):
    try:
        body = await request.json()
    except:
        return json_rpc_response(None, error={"code": -32700, "message": "Parse error"})
    
    method = body.get("method")
    req_id = body.get("id", -1)
    params = body.get("params", {})
    
    try:
        if method == "initialize":
            return json_rpc_response(req_id, {
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}, "resources": {}},
                "serverInfo": {"name": "schoology-copilot", "version": "0.1.0"}
            })
        
        elif method in ("tools/list", "list_tools"):
            tool_dicts = tools.list_tools()
            return json_rpc_response(req_id, {"tools": tool_dicts})
        
        elif method in ("tools/call", "call_tool"):
            name = params.get("name")
            args = params.get("arguments") or params.get("args", {})
            
            result_object = tools.call_tool(name, args, db)
            serialized = serialize_mcp_result(result_object)
            return json_rpc_response(req_id, serialized)
        
        elif method in ("resources/list", "list_resources"):
            return json_rpc_response(req_id, {"resources": resources.list_resources()})
        
        elif method in ("resources/read", "read_resource"):
            uri = params.get("uri") or (params.get("params", {})).get("uri")
            result = resources.read_resource(uri)
            if result:
                return json_rpc_response(req_id, result)
            return json_rpc_response(req_id, error={"code": 1, "message": "Not found"})
        
        else:
            return json_rpc_response(req_id, error={"code": -32601, "message": f"Method not found: {method}"})
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        return json_rpc_response(req_id, error={"code": -32603, "message": str(e)})

______________


web/briefing-widget/vite.config.js
----
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  base: './', 
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    rollupOptions: {
      output: {
        // This ensures predictable filenames with hashes for cache busting
        entryFileNames: 'assets/index-[hash].js',
        chunkFileNames: 'assets/index-[hash].js',
        assetFileNames: 'assets/index-[hash].[ext]'
      }
    }
  }
})

______________


web/briefing-widget/dist/index.html
----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Briefing Widget</title>
    <script type="module" crossorigin src="./assets/index-V2OAM4rW.js"></script>
    <link rel="stylesheet" crossorigin href="./assets/index-D-9fA65y.css">
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>


______________


web/briefing-widget/src/App.jsx
----
import React, { useState, useEffect, useMemo } from 'react';
import dayjs from 'dayjs';
import calendar from 'dayjs/plugin/calendar';
import relativeTime from 'dayjs/plugin/relativeTime';
dayjs.extend(calendar);
dayjs.extend(relativeTime);

// A helper function to create date groups
const groupAssignmentsByDay = (assignments) => {
  if (!assignments || assignments.length === 0) {
    return {};
  }
  
  const grouped = assignments.reduce((acc, assignment) => {
    // dayjs().calendar() is powerful. It returns strings like:
    // "Today at 11:59 PM", "Tomorrow at 1:55 PM", "Last Friday at 2:00 PM", "10/17/2025"
    // We can split on " at " to get just the day part.
    const dayKey = dayjs(assignment.dueAt).calendar(null, {
      sameDay: '[Today]',
      nextDay: '[Tomorrow]',
      nextWeek: 'dddd, MMM D', // e.g., "Friday, Oct 17"
      sameElse: 'MMM D, YYYY'
    });
    
    if (!acc[dayKey]) {
      acc[dayKey] = [];
    }
    acc[dayKey].push(assignment);
    return acc;
  }, {});

  return grouped;
};


function App() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    if (window.openai) {
      const initialData = window.openai.toolResponseMetadata?.ui;
      if (initialData) {
        setData(initialData);
      }
      
      const handleUpdate = (event) => {
        if (event.detail.globals.toolResponseMetadata) {
          setData(event.detail.globals.toolResponseMetadata.ui);
        }
      };
      
      window.addEventListener("openai:set_globals", handleUpdate);
      return () => {
        window.removeEventListener("openai:set_globals", handleUpdate);
      };
    }
  }, []);
  
  const assignments = data?.assignments ?? [];
  const count = data?.count ?? 0;
  const rangeLabel = data?.rangeLabel || 'soon';
  const generatedAt = data?.generatedAt ? dayjs(data.generatedAt) : null;
  
  // useMemo will cache the result of grouping so it doesn't re-run on every render
  const groupedAssignments = useMemo(() => groupAssignmentsByDay(assignments), [assignments]);
  
  if (!data) {
    return (
      <div className="briefing-container">
        <div className="loading-state">
          <div className="spinner"></div>
          <p>Loading briefing...</p>
        </div>
      </div>
    );
  }
  
  return (
    <div className="briefing-container">
      <header>
        <h3>ðŸ“š Daily Briefing</h3>
        {generatedAt && (
          <p className="timestamp" title={generatedAt.format('YYYY-MM-DD HH:mm:ss')}>
            Updated {generatedAt.fromNow()}
          </p>
        )}
      </header>
      
      <div className="summary-card">
        <div className="count">{count}</div>
        <div className="label">
          assignment{count !== 1 ? 's' : ''} due {rangeLabel}
        </div>
      </div>
      
      {assignments.length > 0 ? (
        <div className="grouped-assignments">
          {Object.entries(groupedAssignments).map(([day, items]) => (
            <div key={day} className="day-group">
              <h4 className="day-header">{day}</h4>
              <ul className="assignment-list">
                {items.map(item => (
                  <li key={item.id}>
                    <a href={item.url} target="_blank" rel="noopener noreferrer">
                      <div className="assignment-info">
                        <div className="title-wrapper">
                          {item.type !== 'Homework' && (
                            <span className={`badge type-${item.type.toLowerCase()}`}>{item.type}</span>
                          )}
                          <span className="title">{item.title}</span>
                        </div>
                        <span className="course">{item.course}</span>
                      </div>
                      <div className="due-date">
                        {dayjs(item.dueAt).format('h:mm a')}
                      </div>
                    </a>
                  </li>
                ))}
              </ul>
            </div>
          ))}
        </div>
      ) : (
        <div className="empty-state">
          âœ¨ No upcoming assignments in this timeframe!
        </div>
      )}
    </div>
  );
}

export default App;

______________


web/briefing-widget/src/index.css
----
:root {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f9fafb;
  color: #111827;
}

body {
  margin: 0;
  padding: 16px;
  box-sizing: border-box;
}

.briefing-container header {
  margin-bottom: 16px;
}

.briefing-container h3 {
  margin: 0 0 4px 0;
  font-size: 1.125rem;
  font-weight: 600;
}

.briefing-container .timestamp {
  margin: 0;
  font-size: 0.75rem;
  color: #6b7280;
}

.summary-card {
  display: flex;
  align-items: baseline;
  gap: 12px;
  background-color: #ffffff;
  padding: 16px;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
  margin-bottom: 20px;
}

.summary-card .count {
  font-size: 2.25rem;
  font-weight: 700;
  line-height: 1;
  color: #1f2937;
}

.summary-card .label {
  font-size: 1rem;
  color: #4b5563;
}

.assignment-list {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.assignment-list li a {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background-color: #ffffff;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
  text-decoration: none;
  color: inherit;
  transition: background-color 0.2s ease, box-shadow 0.2s ease;
}

.assignment-list li a:hover {
    background-color: #f9fafb;
    box-shadow: 0 0 0 2px #d1d5db;
}

.assignment-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}

.assignment-info .course {
  font-size: 0.875rem;
  color: #6b7280;
}

.due-date {
    font-size: 0.875rem;
    color: #4b5563;
    flex-shrink: 0;
    margin-left: 16px;
    font-weight: 500;
}

.loading-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  color: #6b7280;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 3px solid #e5e7eb;
  border-top-color: #3b82f6;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-bottom: 12px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.empty-state {
  text-align: center;
  padding: 32px;
  color: #6b7280;
  font-size: 0.95rem;
}

.day-group {
  margin-bottom: 24px;
}

.day-header {
  font-size: 1rem;
  font-weight: 600;
  color: #1f2937;
  margin: 0 0 12px 4px;
  padding-bottom: 4px;
  border-bottom: 1px solid #e5e7eb;
}

.title-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 0; /* Important for flexbox truncation */
}

.title-wrapper .title {
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.badge {
  padding: 2px 8px;
  font-size: 0.7rem;
  font-weight: 600;
  border-radius: 99px;
  flex-shrink: 0; /* Prevent the badge from shrinking */
  text-transform: uppercase;
}

.badge.type-test { background-color: #fee2e2; color: #b91c1c; }
.badge.type-quiz { background-color: #dbeafe; color: #1e40af; }
.badge.type-project { background-color: #d1fae5; color: #065f46; }
.badge.type-paper { background-color: #fef3c7; color: #92400e; }

______________


web/briefing-widget/src/index.jsx
----
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)


______________