.env
----
# Schoology Co-Pilot Configuration

# --- Authentication ---
# Full session cookie string extracted directly from your provided network request log.
OLD_SCHOOLOGY_COOKIE="s_stats_browser_info=%7B%22pluginInfo%22%3A%7B%22pdf%22%3A%5B%22pdf%22%2C%22application/pdf%22%2C%221%22%5D%2C%22quicktime%22%3A%5B%22qt%22%2C%22video/quicktime%22%2C%220%22%5D%2C%22realplayer%22%3A%5B%22realp%22%2C%22audio/x-pn-realaudio-plugin%22%2C%220%22%5D%2C%22wma%22%3A%5B%22wma%22%2C%22application/x-mplayer2%22%2C%220%22%5D%2C%22director%22%3A%5B%22dir%22%2C%22application/x-director%22%2C%220%22%5D%2C%22flash%22%3A%5B%22fla%22%2C%22application/x-shockwave-flash%22%2C%220%22%5D%2C%22java%22%3A%5B%22java%22%2C%22application/x-java-vm%22%2C%220%22%5D%2C%22gears%22%3A%5B%22gears%22%2C%22application/x-googlegears%22%2C%220%22%5D%2C%22silverlight%22%3A%5B%22ag%22%2C%22application/x-silverlight%22%2C%220%22%5D%7D%2C%22res%22%3A%221710x1112%22%7D; apt.uid=AP-IBYB1G3SIPA6-2-1759590066364-73921151.0.2.2249589b-9e64-489d-b3c6-4a45306f0912; has_js=1; cbLDB=1; SESS203b9bead5ca8f4fbb607005f50a33ad=6f3823c5497bb99fa272a6abc8791465; apt.sid=AP-IBYB1G3SIPA6-2-1759893165423-56892569"

SCHOOLOGY_COOKIE="apt.uid=AP-IBYB1G3SIPA6-2-1759590066364-73921151.0.2.2249589b-9e64-489d-b3c6-4a45306f0912; _gcl_au=1.1.327145066.1759925919; _ga=GA1.1.1696360727.1759925919; _fbp=fb.1.1759925919402.830911096779083779; _ga_TZBJ5BZWDC=GS2.1.s1759925919$o1$g1$t1759925993$j60$l0$h0; s_stats_browser_info=%7B%22pluginInfo%22%3A%7B%22pdf%22%3A%5B%22pdf%22%2C%22application/pdf%22%2C%221%22%5D%2C%22quicktime%22%3A%5B%22qt%22%2C%22video/quicktime%22%2C%220%22%5D%2C%22realplayer%22%3A%5B%22realp%22%2C%22audio/x-pn-realaudio-plugin%22%2C%220%22%5D%2C%22wma%22%3A%5B%22wma%22%2C%22application/x-mplayer2%22%2C%220%22%5D%2C%22director%22%3A%5B%22dir%22%2C%22application/x-director%22%2C%220%22%5D%2C%22flash%22%3A%5B%22fla%22%2C%22application/x-shockwave-flash%22%2C%220%22%5D%2C%22java%22%3A%5B%22java%22%2C%22application/x-java-vm%22%2C%220%22%5D%2C%22gears%22%3A%5B%22gears%22%2C%22application/x-googlegears%22%2C%220%22%5D%2C%22silverlight%22%3A%5B%22ag%22%2C%22application/x-silverlight%22%2C%220%22%5D%7D%2C%22res%22%3A%221710x1112%22%7D; has_js=1; SESS203b9bead5ca8f4fbb607005f50a33ad=2d1a667d6283d286f7871184848f7359; cbLDB=1; apt.sid=AP-IBYB1G3SIPA6-2-1760544200321-92543786"
# Your Schoology user ID, extracted from the calendar URL.
SCHOOLOGY_USER_ID="105724617"

# Comma-separated list of your course IDs, extracted from the URLs provided.
SCHOOLOGY_COURSE_IDS="7890186853,7890186902,7890186797,7890186817,7890186659,7890656563"

# --- Server Configuration ---
# Host on 0.0.0.0 to be accessible from your router's port forwarding.
APP_HOST="0.0.0.0"

# Port your router is forwarding to on this machine.
APP_PORT="5544"


WIDGET_BASE_URL="https://smooth-content-porpoise.ngrok-free.app/widget"


______________


.env.test
----
# Schoology Co-Pilot Configuration

# --- Authentication ---
# Full session cookie string extracted directly from your provided network request log.
OLD_SCHOOLOGY_COOKIE="s_stats_browser_info=%7B%22pluginInfo%22%3A%7B%22pdf%22%3A%5B%22pdf%22%2C%22application/pdf%22%2C%221%22%5D%2C%22quicktime%22%3A%5B%22qt%22%2C%22video/quicktime%22%2C%220%22%5D%2C%22realplayer%22%3A%5B%22realp%22%2C%22audio/x-pn-realaudio-plugin%22%2C%220%22%5D%2C%22wma%22%3A%5B%22wma%22%2C%22application/x-mplayer2%22%2C%220%22%5D%2C%22director%22%3A%5B%22dir%22%2C%22application/x-director%22%2C%220%22%5D%2C%22flash%22%3A%5B%22fla%22%2C%22application/x-shockwave-flash%22%2C%220%22%5D%2C%22java%22%3A%5B%22java%22%2C%22application/x-java-vm%22%2C%220%22%5D%2C%22gears%22%3A%5B%22gears%22%2C%22application/x-googlegears%22%2C%220%22%5D%2C%22silverlight%22%3A%5B%22ag%22%2C%22application/x-silverlight%22%2C%220%22%5D%7D%2C%22res%22%3A%221710x1112%22%7D; apt.uid=AP-IBYB1G3SIPA6-2-1759590066364-73921151.0.2.2249589b-9e64-489d-b3c6-4a45306f0912; has_js=1; cbLDB=1; SESS203b9bead5ca8f4fbb607005f50a33ad=6f3823c5497bb99fa272a6abc8791465; apt.sid=AP-IBYB1G3SIPA6-2-1759893165423-56892569"

SCHOOLOGY_COOKIE="s_stats_browser_info=%7B%22pluginInfo%22%3A%7B%22pdf%22%3A%5B%22pdf%22%2C%22application/pdf%22%2C%221%22%5D%2C%22quicktime%22%3A%5B%22qt%22%2C%22video/quicktime%22%2C%220%22%5D%2C%22realplayer%22%3A%5B%22realp%22%2C%22audio/x-pn-realaudio-plugin%22%2C%220%22%5D%2C%22wma%22%3A%5B%22wma%22%2C%22application/x-mplayer2%22%2C%220%22%5D%2C%22director%22%3A%5B%22dir%22%2C%22application/x-director%22%2C%220%22%5D%2C%22flash%22%3A%5B%22fla%22%2C%22application/x-shockwave-flash%22%2C%220%22%5D%2C%22java%22%3A%5B%22java%22%2C%22application/x-java-vm%22%2C%220%22%5D%2C%22gears%22%3A%5B%22gears%22%2C%22application/x-googlegears%22%2C%220%22%5D%2C%22silverlight%22%3A%5B%22ag%22%2C%22application/x-silverlight%22%2C%220%22%5D%7D%2C%22res%22%3A%221710x1112%22%7D; apt.uid=AP-IBYB1G3SIPA6-2-1759590066364-73921151.0.2.2249589b-9e4-489d-b3c6-4a45306f0912; _gcl_au=1.1.327145066.1759925919; _ga=GA1.1.1696360727.1759925919; _fbp=fb.1.1759925919402.830911096779083779; _ga_TZBJ5BZWDC=GS2.1.s1759925919$o1$g1$t1759925993$j60$l0$h0; SESS203b9bead5ca8f4fbb607005f50a33ad=e6f7545e29b61e075d8a1775279de3e8; has_js=1; cbLDB=1; apt.sid=AP-IBYB1G3SIPA6-2-1760045188011-24362626"
# --- Identifiers ---
# Your Schoology user ID, extracted from the calendar URL.
SCHOOLOGY_USER_ID="105724617"

# Comma-separated list of your course IDs, extracted from the URLs provided.
SCHOOLOGY_COURSE_IDS="7890186853,7890186902,7890186797,7890186817,7890186659,7890656563"

# --- Server Configuration ---
# Host on 0.0.0.0 to be accessible from your router's port forwarding.
APP_HOST="0.0.0.0"

# Port your router is forwarding to on this machine.
APP_PORT="5544"

______________


PROJECT.md
----
# `PROJECT.md`

## Project Name: Schoology Co-Pilot

### 1. Project Goal

To create a conversational agent within ChatGPT that provides a unified, proactive interface to a student's Schoology data. This project will be implemented as a single, self-contained Python application running locally on a desktop PC. It will handle data fetching, storage, and serving requests from the OpenAI Apps SDK via the Model Context Protocol (MCP).

### 2. Core Architecture

The application consists of three primary, concurrently operating components:

1.  **Data Synchronizer:** A background scheduler (`apscheduler`) that periodically fetches data from Schoology's internal web APIs.
2.  **Local Data Mirror:** A single-file SQLite database (`schoology.db`) that stores a structured, clean version of the fetched data. SQLAlchemy will be used as the ORM.
3.  **MCP Server:** A FastAPI application running on Uvicorn that exposes a `/mcp` endpoint. It serves near-instantaneous responses to ChatGPT by querying the local SQLite database, not by making live requests to Schoology.

### 3. Tech Stack

*   **Backend Framework:** FastAPI with Uvicorn
*   **Web Client:** `requests`
*   **HTML Parsing:** `beautifulsoup4`
*   **Scheduling:** `apscheduler`
*   **Database/ORM:** SQLite with SQLAlchemy
*   **Configuration:** `python-dotenv`
*   **Frontend (UI Component):** React (This part is separate and will be built in the `web/` directory)

### 4. Project Structure

```
schoology-copilot/
├── app/
│   ├── database/
│   │   ├── crud.py         # Data access functions (Create, Read, Update).
│   │   ├── database.py     # SQLAlchemy engine and session management.
│   │   └── models.py       # SQLAlchemy ORM models (tables).
│   ├── mcp_server/
│   │   ├── server.py       # FastAPI app definition and /mcp route.
│   │   └── tools.py        # Logic for each MCP tool (e.g., get_daily_briefing).
│   ├── scheduler/
│   │   ├── scheduler.py    # APScheduler initialization and management.
│   │   └── sync_job.py     # The main synchronization task function.
│   └── schoology_client/
│       └── client.py       # Class-based client for making requests to Schoology.
├── web/                      # React frontend components (handled separately).
├── main.py                   # Main application entry point.
├── schoology.db              # Local SQLite database file.
├── requirements.txt
├── .env
└── .gitignore
```

### 5. Implementation Details & Data Flow

#### **Step 1: Configuration (`.env`)**

*   Authentication with Schoology will be handled via a session cookie.
*   The `.env` file must contain:
    *   `SCHOOLOGY_COOKIE`: The full cookie string copied from a logged-in browser session.
    *   `SCHOOLOGY_USER_ID`: The user's unique ID found in Schoology URLs.
    *   `SCHOOLOGY_COURSE_IDS`: A comma-separated list of numeric course IDs for targeted scraping.

#### **Step 2: Schoology Client (`app/schoology_client/client.py`)**

*   A `SchoologyClient` class will encapsulate all web requests.
*   It will initialize with headers containing the `SCHOOLOGY_COOKIE` from the `.env` file.
*   It must implement methods to fetch key data points. Start with:
    *   `get_calendar_events(start_ts, end_ts)`: Hits the `/calendar/...` endpoint. This returns structured JSON directly.
    *   `get_feed_updates()`: Hits the `/home/feed` endpoint. This returns JSON containing an HTML blob that must be parsed with BeautifulSoup.
    *   `get_grades(course_id)`: (Endpoint to be discovered) Fetches grades for a specific course.
    *   `get_course_assignments(course_id)`: Hits the `/course/.../materials?list_filter=assignments` endpoint. This returns JSON with HTML to be parsed.

#### **Step 3: Database Models (`app/database/models.py`)**

*   Define SQLAlchemy ORM models for each data type. All models should inherit from a declarative `Base`.
*   **`Assignment` Model:** `id` (Schoology's ID, primary key), `title`, `due_date`, `course_name`, `url`.
*   **`Event` Model:** `id`, `title`, `start_time`, `end_time`, `source` (e.g., 'Class of 2026').
*   **`Update` Model:** `id`, `author`, `content_html`, `timestamp`, `source`.
*   **`Grade` Model:** `id`, `assignment_title`, `score_raw` (e.g., "92/100"), `course_name`.

#### **Step 4: Data Synchronization (`app/scheduler/sync_job.py`)**

*   The `sync_schoology_data()` function is the core of the cron job.
*   On each run, it will:
    1.  Instantiate `SchoologyClient`.
    2.  Get a new database session (`SessionLocal()`).
    3.  Call the client's fetch methods to get fresh data.
    4.  Iterate through the results. For each item (e.g., an assignment), use a `crud` function to perform an "upsert":
        *   If an assignment with that ID already exists in the database, update its fields.
        *   If it doesn't exist, create a new record.
    5.  Commit the session and close it.

#### **Step 5: MCP Server (`app/mcp_server/`)**

*   The `server.py` file will define the FastAPI application.
*   It will have a single POST route: `/mcp`.
*   This route will handle `list_tools` and `call_tool` requests.
*   The logic for `call_tool` will be delegated to functions in `tools.py`.
*   **Tool Functions (e.g., `build_daily_briefing(db: Session)`) will exclusively query the local SQLite database via `crud` functions.** They must **NOT** call the `SchoologyClient`. This ensures speed.
*   The tool function will format the data from the database into the required `structuredContent` JSON payload for the MCP response.

#### **Step 6: Main Entry Point (`main.py`)**

*   This script ties everything together. It will:
    1.  Load environment variables from `.env` using `dotenv`.
    2.  Initialize the database tables using `Base.metadata.create_all(bind=engine)`.
    3.  Instantiate and start the `apscheduler` in a background thread, configured to run `sync_schoology_data()` every 5 minutes.
    4.  Run the FastAPI application using `uvicorn.run()`.

______________


README.md
----
# Schoology Co-Pilot

A conversational agent that transforms the fragmented Schoology platform into a unified, proactive assistant for students within ChatGPT.

## Quick Start

### 1. Install Dependencies

```bash
pip install -r requirements.txt
```

### 2. Configure Environment

Copy the `.env` file and fill in your Schoology credentials:

```bash
cp .env .env.local
# Edit .env.local with your actual values
```

Required environment variables:
- `SCHOOLOGY_COOKIE`: Your session cookie from a logged-in browser
- `SCHOOLOGY_USER_ID`: Your user ID (found in Schoology URLs)
- `SCHOOLOGY_COURSE_IDS`: Comma-separated list of course IDs to monitor

### 3. Seed Sample Data (Optional)

For testing purposes, you can add sample assignments:

```bash
python seed_data.py
```

### 4. Run the Application

```bash
python main.py
```

The MCP server runs at `http://<APP_HOST>:<APP_PORT>` (defaults in `.env`).
Example with your `.env`: `http://0.0.0.0:5544`

## Project Structure

```
schoology-copilot/
├── app/
│   ├── database/          # SQLAlchemy models and database setup
│   ├── mcp_server/        # FastAPI MCP server and tools
│   ├── scheduler/         # Background data synchronization
│   └── schoology_client/  # Schoology API client
├── web/                   # React frontend (future)
├── main.py               # Application entry point
├── seed_data.py          # Sample data seeder
└── requirements.txt      # Python dependencies
```

## Features

### Current (Stub Implementation)
- **System Ping**: Basic connectivity test
- **Daily Briefing**: Shows upcoming assignments (with sample data)

### Planned
- **Performance Dashboard**: Grade tracking and trends
- **Interactive Planner**: Kanban-style task management
- **Proactive Alerts**: Real-time notifications for new grades/assignments

## Development

The application consists of three main components:

1. **Data Synchronizer**: Background scheduler that fetches data from Schoology
2. **Local Data Mirror**: SQLite database storing structured data
3. **MCP Server**: FastAPI server exposing tools to ChatGPT

## API Endpoints

- `GET /healthz` - Health check
- `POST /mcp` - MCP protocol endpoint (JSON-RPC 2.0)

## MCP Tools (JSON-RPC 2.0)
**List tools**
```bash
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":1,"method":"list_tools"}'
```
**Call `system.ping`**
```bash
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":2,"method":"call_tool","params":{"name":"system.ping"}}'
```
**Call `briefing.get`**
```bash
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":3,"method":"call_tool","params":{"name":"briefing.get","args":{"range":"48h"}}}'
```

## Next Steps

1. Implement real Schoology API endpoints in `SchoologyClient`
2. Add grade tracking and performance dashboard
3. Build interactive planner with Kanban board
4. Create React frontend components
5. Add real-time notifications and alerts

______________


VISION.md
----
# `VISION.md`

## Project: Schoology Co-Pilot

### High-Level Vision

The Schoology Co-Pilot is a conversational agent, built on the OpenAI Apps SDK, that transforms the fragmented and noisy Schoology platform into a unified, proactive, and actionable assistant for students. It eliminates the cognitive load of navigating countless pages and feeds by synthesizing all critical academic and campus life information into a single, intelligent dialogue within ChatGPT.

### The Problem with the Current State

Schoology serves as a digital repository but forces the student to be a reactive information hunter. The core pain points are:

*   **Information Silos:** Critical data is scattered across a dozen separate Course and Group pages, with no single source of truth.
*   **Signal vs. Noise:** The main feed is a chronological firehose where urgent deadlines, new grades, and low-priority announcements have the same visual weight.
*   **Reactive Workflow:** The student must manually and repeatedly pull information, check for updates, and synthesize connections in their own mind.

### The Co-Pilot Vision

The Schoology Co-Pilot will be an intelligent partner that manages the logistics of student life, allowing the student to focus on learning and participation. It will provide:

*   A **unified view** of all courses, groups, grades, and deadlines.
*   **Proactive insights** that surface what's important, right now.
*   **Actionable components** that turn information into plans and actions directly within the chat.

It moves the user from being an "information puller" to a "decision maker."

---

## Core Features

### 1. The Daily Briefing

*   **Description:** This is the cornerstone feature. At any time, the user can ask for a complete, prioritized summary of their academic and campus life. The Co-Pilot will scan all courses and groups to synthesize a single, digestible intelligence report.
*   **Interaction:** The user prompts, "What's my daily briefing?" or "What's up for today?". The Co-Pilot responds with a rich, interactive component that displays:
    *   **High-Priority Tasks:** Assignments and assessments due within the next 24-48 hours.
    *   **Key Announcements:** An intelligent summary of important new posts, filtering out social chatter.
    *   **Upcoming Events:** A unified calendar view of class events, club meetings, and school-wide deadlines.
*   **Example Prompts:**
    *   `"What's my briefing?"`
    *   `"What do I need to worry about today?"`
    *   `"Give me a rundown of the week."`

### 2. The Performance Dashboard

*   **Description:** This feature transforms the stressful, reactive process of checking grades into a proactive and insightful experience. It tracks grade changes, provides context, and helps the user understand their academic standing at a glance.
*   **Interaction:** When a new grade is posted, the Co-Pilot can proactively alert the user. The user can also ask, "How are my grades?". The Co-Pilot will render an interactive component showing:
    *   **New Grade Alerts:** A prominent notification for any recently posted grade.
    *   **Class Averages:** A clean list of current averages for all courses.
    *   **Performance Trends:** Simple visual indicators (e.g., `↑` or `↓`) to show if a grade has improved or declined since the last new entry. The user can then ask follow-up questions like, `"Why did my Physics grade change?"` to get a breakdown.
*   **Example Prompts:**
    *   `"Any new grades?"`
    *   `"How am I doing in AP Calculus?"`
    *   `"Show me my current academic performance."`

### 3. The Interactive Planner

*   **Description:** This feature turns the static "To-Do" list into a dynamic, personal planning workspace. It allows the user to organize their assignments and personal tasks, turning intent into a concrete plan.
*   **Interaction:** The user prompts, "Help me plan my night." The Co-Pilot fetches all upcoming assignments and presents them in a `fullscreen` Kanban-style board component. The user can:
    *   **Prioritize:** Drag and drop tasks into "To Do," "In Progress," and "Done" columns.
    *   **Augment:** Add their own personal tasks (e.g., "Study for SAT," "Finish college essay").
    *   **Persist:** The state of the board is saved, so the plan is always up-to-date and can be revisited in any future conversation.
*   **Example Prompts:**
    *   `"Let's plan my week."`
    *   `"I have 3 hours to work, what should I focus on?"`
    *   `"Show me my current plan."`

______________


WIDGET_SETUP.md
----
# Widget Setup Guide

## Overview

Your Schoology Co-Pilot widget has been simplified to use the **CDN pattern** instead of inline HTML. This approach is more reliable and easier to debug.

## How It Works

1. **Widget HTML Shell**: The widget serves a simple HTML shell that loads your React app from `localhost:8080`
2. **Asset Server**: A separate Python script serves your built React assets
3. **MCP Integration**: ChatGPT loads the widget and fetches data from your MCP server

## Setup Instructions

### Step 1: Build Your React Widget

```bash
cd web/briefing-widget
npm run build
```

### Step 2: Start the Widget Asset Server

In a separate terminal:

```bash
# From the project root
python serve_widget.py
```

This will serve your built React app on `http://localhost:8080`

### Step 3: Start Your MCP Server

In another terminal:

```bash
# From the project root
python main.py
```

### Step 4: Test the Widget

Your widget should now be accessible through ChatGPT. The widget will:
- Load the HTML shell from your MCP server
- Fetch React assets from `localhost:8080`
- Display your interactive briefing widget

## File Changes Made

### `app/mcp_server/resources.py`
- ✅ Simplified to use CDN pattern
- ✅ Removed complex inline HTML generation
- ✅ Uses simple HTML shell that loads from localhost:8080

### `app/mcp_server/tools.py`
- ✅ Updated to use proper widget metadata
- ✅ Added embedded resource support
- ✅ Simplified tool response format

### `app/mcp_server/server.py`
- ✅ Removed SSE endpoints (not needed)
- ✅ Simplified JSON-RPC handling
- ✅ Cleaner, more maintainable code

## Troubleshooting

### Widget Not Loading?
1. Make sure `serve_widget.py` is running on port 8080
2. Check that `web/briefing-widget/dist` exists
3. Verify your React build completed successfully

### CORS Issues?
The widget server includes CORS headers for ChatGPT compatibility.

### Port Conflicts?
If port 8080 is in use, you can modify the port in both:
- `serve_widget.py` (line with `PORT = 8080`)
- `app/mcp_server/resources.py` (the localhost URLs)

## Benefits of This Approach

1. **Reliability**: No more complex file reading and inlining
2. **Debugging**: Easy to inspect network requests in browser dev tools
3. **Development**: Hot reload works with your React dev server
4. **Maintainability**: Cleaner separation of concerns

## Next Steps

1. Test the widget through ChatGPT
2. Verify data loading and display works correctly
3. Customize the React widget as needed
4. Deploy both servers when ready for production



______________


build-and-run.sh
----
#!/bin/bash

set -e  # Exit on any error

echo "🚀 Building and Starting Schoology Co-Pilot"
echo ""

# Build the widget
echo "📦 Building React widget..."
cd web/briefing-widget
npm run build
cd ../..

echo "✅ Widget built successfully"
echo ""
echo "🌐 Starting MCP server (serves widget at /widget)..."
echo ""
python main.py

______________


main.py
----
# main.py

import uvicorn
import os
import logging
from app.mcp_server.server import app

def main():
    """Main entry point to run the application."""
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - [%(threadName)s] - %(message)s'
    )

    # Get host and port from environment, with defaults
    # Note: load_dotenv() is now called inside the lifespan manager
    host = os.getenv("APP_HOST", "0.0.0.0")
    port = int(os.getenv("APP_PORT", "5544")) # Default to your port
    
    logging.info(f"🚀 Starting Uvicorn server process on http://{host}:{port}")
    # Run the FastAPI app using uvicorn
    # The 'app' object now contains the lifespan logic
    uvicorn.run(app, host=host, port=port)

if __name__ == "__main__":
    main()

______________


requirements.txt
----
fastapi>=0.115
uvicorn[standard]>=0.30
SQLAlchemy>=2.0
python-dotenv>=1.0
APScheduler>=3.10
requests>=2.32
beautifulsoup4>=4.12
bleach>=6.1
pydantic>=2.7
mcp>=1.0.0
aiofiles>=23.0.0

______________


seed_data.py
----
#!/usr/bin/env python3
"""
Quick seeder script to add sample data for testing.
Run this once to populate the database with sample assignments.
"""

from app.database.database import SessionLocal, init_db
from app.database.models import Assignment
from datetime import datetime, timedelta, timezone

def seed_sample_data():
    """Add sample assignments to the database for testing."""
    init_db()
    db = SessionLocal()
    
    try:
        # Add a few sample assignments
        sample_assignments = [
            Assignment(
                id=1001, 
                course_id=1, 
                course_name="AP Calculus", 
                title="Homework 1: Limits and Continuity",
                due_at_utc=datetime.now(timezone.utc) + timedelta(hours=12), 
                url="https://example.com/calc-hw1"
            ),
            Assignment(
                id=1002, 
                course_id=2, 
                course_name="AP Physics", 
                title="Lab Report: Projectile Motion",
                due_at_utc=datetime.now(timezone.utc) + timedelta(hours=36), 
                url="https://example.com/physics-lab1"
            ),
            Assignment(
                id=1003, 
                course_id=3, 
                course_name="English Literature", 
                title="Essay: Analysis of 'The Great Gatsby'",
                due_at_utc=datetime.now(timezone.utc) + timedelta(days=3), 
                url="https://example.com/english-essay1"
            ),
        ]
        
        for assignment in sample_assignments:
            db.add(assignment)
        
        db.commit()
        print(f"✅ Added {len(sample_assignments)} sample assignments to the database")
        
    except Exception as e:
        db.rollback()
        print(f"❌ Error seeding data: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    seed_sample_data()


______________


serve_widget.py
----
#!/usr/bin/env python3
"""
Simple static file server for the widget assets.
Run this script to serve your built React widget on localhost:8080
"""

import http.server
import socketserver
import os
import sys
from pathlib import Path

def main():
    # Check if dist folder exists
    dist_path = Path("web/briefing-widget/dist")
    if not dist_path.exists():
        print("❌ Error: dist folder not found at web/briefing-widget/dist")
        print("Please run: cd web/briefing-widget && npm run build")
        sys.exit(1)
    
    # Change to dist directory
    os.chdir(dist_path)
    
    PORT = 8080
    
    class Handler(http.server.SimpleHTTPRequestHandler):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, directory=str(dist_path), **kwargs)
        
        def end_headers(self):
            # Add CORS headers for ChatGPT
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
            self.send_header('Access-Control-Allow-Headers', 'Content-Type')
            super().end_headers()
    
    with socketserver.TCPServer(("", PORT), Handler) as httpd:
        print(f"🚀 Widget server running at http://localhost:{PORT}")
        print(f"📁 Serving files from: {dist_path.absolute()}")
        print("Press Ctrl+C to stop")
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            print("\n👋 Widget server stopped")

if __name__ == "__main__":
    main()



______________


start.sh
----
#!/bin/bash

echo "🚀 Starting Schoology Co-Pilot"
echo ""

# Build the widget
echo "📦 Building widget..."
cd web/briefing-widget
npm run build
cd ../..

# Start the widget server in background
echo "🌐 Starting widget server on :8080..."
python3 web/briefing-widget/serve.py &
WIDGET_PID=$!

# Wait for server to start
sleep 2

echo ""
echo "✅ Widget server running on http://localhost:8080"
echo ""
echo "📝 In another terminal, run:"
echo "   ngrok start --all"
echo ""
echo "Then get your widget URL from ngrok dashboard and update .env:"
echo "   WIDGET_BASE_URL=\"https://your-widget-tunnel.ngrok-free.app\""
echo ""
echo "Finally, start the MCP server in a third terminal:"
echo "   python main.py"
echo ""
echo "Press Ctrl+C to stop widget server"

# Wait for interrupt
trap "kill $WIDGET_PID; exit" INT
wait

______________


test_client.py
----
# test_client.py

import os
from dotenv import load_dotenv
from datetime import datetime, timedelta, timezone
from app.schoology_client.client import SchoologyClient

def test_calendar_fetch():
    """
    Loads environment variables and fetches calendar events for the next 30 days.
    """
    # Load .env file from the project root
    print("Loading environment variables...")
    load_dotenv()

    # Check if credentials are loaded
    cookie = os.getenv("SCHOOLOGY_COOKIE")
    user_id = os.getenv("SCHOOLOGY_USER_ID")
    if not cookie or not user_id:
        print("❌ ERROR: SCHOOLOGY_COOKIE and SCHOOLOGY_USER_ID must be set in your .env file.")
        return

    print("Credentials loaded. Initializing Schoology Client...")
    client = SchoologyClient()

    # Define the time range: from now to 30 days from now
    now = datetime.now(timezone.utc)
    end_date = now + timedelta(days=30)
    
    start_timestamp = int(now.timestamp())
    end_timestamp = int(end_date.timestamp())

    print(f"\nFetching events from {now.isoformat()} to {end_date.isoformat()}...")
    events = client.get_calendar_events(start_ts=start_timestamp, end_ts=end_timestamp)

    if not events:
        print("\n❌ No events returned. Check the following:")
        print("   1. Is your SCHOOLOGY_COOKIE valid and not expired?")
        print("   2. Is the SCHOOLOGY_USER_ID correct?")
        print("   3. Is there an issue with the constructed URL or network connectivity?")
        return

    print(f"\n✅ Successfully fetched {len(events)} events!")
    print("--- Sample Events ---")
    
    for i, event in enumerate(events[:5]): # Print the first 5 events
        event_type = event.get('e_type', 'N/A')
        title = event.get('titleText', 'No Title')
        source = event.get('content_title', 'N/A')
        start_time = event.get('start', 'N/A')
        
        print(f"\nEvent {i+1}:")
        print(f"  Title: {title}")
        print(f"  Type: {event_type}")
        print(f"  Source: {source}")
        print(f"  Start Time: {start_time}")
    
    print("\n--- End of Sample ---")


if __name__ == "__main__":
    test_calendar_fetch()

______________


test_mcp.py
----
#!/usr/bin/env python3
"""
Test script for MCP methods
"""
import requests
import json

BASE_URL = "http://127.0.0.1:5544/mcp"

def test_mcp_method(method, params=None):
    """Test an MCP method"""
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": method
    }
    if params:
        payload["params"] = params
    
    try:
        response = requests.post(BASE_URL, json=payload, headers={"Content-Type": "application/json"})
        print(f"\n=== Testing {method} ===")
        print(f"Request: {json.dumps(payload, indent=2)}")
        print(f"Response: {json.dumps(response.json(), indent=2)}")
        return response.json()
    except Exception as e:
        print(f"Error testing {method}: {e}")
        return None

if __name__ == "__main__":
    print("Testing MCP methods...")
    
    # Test initialize
    test_mcp_method("initialize", {
        "protocolVersion": "2024-11-05",
        "capabilities": {},
        "clientInfo": {"name": "test-client", "version": "1.0"}
    })
    
    # Test tools/list
    test_mcp_method("tools/list")
    
    # Test tools/call
    test_mcp_method("tools/call", {
        "name": "briefing.get",
        "arguments": {"range": "48h"}
    })
    
    # Test legacy methods for backward compatibility
    test_mcp_method("list_tools")
    test_mcp_method("call_tool", {
        "name": "briefing.get",
        "args": {"range": "48h"}
    })


______________


test_mcp_curl.sh
----
#!/bin/bash
# Test script for MCP methods using curl

echo "Testing MCP methods with curl..."

echo -e "\n=== Testing initialize ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"curl","version":"1"}}}' | jq .

echo -e "\n=== Testing tools/list ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":2,"method":"tools/list"}' | jq .

echo -e "\n=== Testing tools/call (briefing.get) ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"briefing.get","arguments":{"range":"48h"}}}' | jq .

echo -e "\n=== Testing legacy list_tools ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":4,"method":"list_tools"}' | jq .

echo -e "\n=== Testing legacy call_tool ==="
curl -s -X POST http://127.0.0.1:5544/mcp \
  -H 'content-type: application/json' \
  -d '{"jsonrpc":"2.0","id":5,"method":"call_tool","params":{"name":"briefing.get","args":{"range":"48h"}}}' | jq .


______________


app/__init__.py
----


______________


app/mcp_server/__init__.py
----


______________


app/mcp_server/resources.py
----
# app/mcp_server/resources.py

import os
import logging
from pathlib import Path

MIME_TYPE = "text/html+skybridge"
WIDGET_URI = "ui://widget/briefing.html"

# Store asset content in memory to avoid reading from disk on every request
_WIDGET_HTML_CACHE = None

def get_widget_html() -> str:
    """
    Reads the built React JS and CSS from the /dist folder and injects
    them into an HTML shell. This is the "inline" pattern from the official docs.
    """
    global _WIDGET_HTML_CACHE
    if _WIDGET_HTML_CACHE:
        return _WIDGET_HTML_CACHE

    try:
        # Find the path to the 'dist' directory relative to this file
        dist_path = Path(__file__).parent.parent.parent / "web" / "briefing-widget" / "dist"
        
        # Find the specific JS and CSS files Vite generates (they have hashes)
        assets_path = dist_path / "assets"
        # Use next() with a generator expression to find the first match
        js_file = next(assets_path.glob("index-*.js"))
        css_file = next(assets_path.glob("index-*.css"))

        js_content = js_file.read_text()
        css_content = css_file.read_text()
        
        html = f"""
<div id="root"></div>
<style>{css_content}</style>
<script type="module">{js_content}</script>
        """.strip()

        _WIDGET_HTML_CACHE = html
        logging.info(f"✅ Successfully loaded and cached widget assets from {dist_path}")
        return html

    except (FileNotFoundError, StopIteration) as e:
        error_msg = "FATAL: Widget asset files not found. Did you run 'npm run build' in /web/briefing-widget?"
        logging.error(f"{error_msg} - {e}")
        return f"""<div style="font-family: sans-serif; padding: 2em; color: red;">
                       <h2>Widget Error</h2><p>{error_msg}</p>
                   </div>"""

def list_resources() -> list[dict]:
    """Return list of resource definitions as dicts."""
    return [{
        "uri": WIDGET_URI,
        "mimeType": MIME_TYPE,
        "name": "Daily Briefing Widget",
        "description": "Interactive daily briefing with assignments"
    }]

def read_resource(uri: str) -> dict | None:
    """Read a resource and return its contents."""
    if uri != WIDGET_URI:
        return None
    
    return {
        "contents": [{
            "uri": WIDGET_URI,
            "mimeType": MIME_TYPE,
            "text": get_widget_html(),
        }]
    }

______________


app/mcp_server/server.py
----
# app/mcp_server/server.py

from fastapi import FastAPI, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
# ✅ IMPORT StaticFiles
from fastapi.staticfiles import StaticFiles
from sqlalchemy.orm import Session
from contextlib import asynccontextmanager
from dotenv import load_dotenv
import os
import mcp.types as types
import logging

from app.database.database import get_db, init_db
from app.scheduler.scheduler import start_scheduler, stop_scheduler
from app.mcp_server import tools, resources

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("🚀 Starting up...")
    load_dotenv()
    init_db()
    start_scheduler()
    yield
    print("👋 Shutting down...")
    stop_scheduler()

app = FastAPI(title="Schoology Co-Pilot", lifespan=lifespan)

# CORS is still important
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ✅ REPLACEMENT FOR serve_widget.py
# Get the absolute path to the widget's 'dist' directory
widget_dist_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'web', 'briefing-widget', 'dist'))

if os.path.exists(widget_dist_path):
    # Mount the entire dist directory at the '/widget' path
    app.mount(
        "/widget",
        StaticFiles(directory=widget_dist_path, html=True),
        name="widget"
    )
    logging.info(f"✅ Widget assets mounted at /widget from {widget_dist_path}")
else:
    logging.error(f"❌ Widget 'dist' folder not found at {widget_dist_path}")
    logging.error("   Please run: cd web/briefing-widget && npm run build")


@app.get("/healthz")
def health():
    return {"ok": True}

# ... (the rest of your server.py file remains the same) ...
# (json_rpc_response, serialize_mcp_result, and the /mcp endpoint are all correct)

def json_rpc_response(request_id, result=None, error=None):
    """Helper to build JSON-RPC 2.0 responses."""
    resp = {"jsonrpc": "2.0", "id": request_id}
    if error:
        resp["error"] = error
    else:
        resp["result"] = result
    return resp

def serialize_mcp_result(result):
    """Convert MCP types to JSON-serializable dicts."""
    if isinstance(result, types.CallToolResult):
        return {
            "content": [
                {"type": c.type, "text": c.text}
                for c in result.content
            ],
            "structuredContent": result.structuredContent,
            "isError": result.isError,
            "_meta": result.meta
        }
    return result

@app.post("/mcp")
async def mcp_endpoint(request: Request, db: Session = Depends(get_db)):
    try:
        body = await request.json()
    except:
        return json_rpc_response(None, error={"code": -32700, "message": "Parse error"})
    
    method = body.get("method")
    req_id = body.get("id", -1)
    params = body.get("params", {})
    
    try:
        if method == "initialize":
            return json_rpc_response(req_id, {
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}, "resources": {}},
                "serverInfo": {"name": "schoology-copilot", "version": "0.1.0"}
            })
        
        elif method in ("tools/list", "list_tools"):
            tool_dicts = tools.list_tools()
            return json_rpc_response(req_id, {"tools": tool_dicts})
        
        elif method in ("tools/call", "call_tool"):
            name = params.get("name")
            args = params.get("arguments") or params.get("args", {})
            
            result_object = tools.call_tool(name, args, db)
            serialized = serialize_mcp_result(result_object)
            return json_rpc_response(req_id, serialized)
        
        elif method in ("resources/list", "list_resources"):
            return json_rpc_response(req_id, {"resources": resources.list_resources()})
        
        elif method == "resources/read":
            uri = params.get("uri")
            result = resources.read_resource(uri)
            if result:
                return json_rpc_response(req_id, result)
            return json_rpc_response(req_id, error={"code": 1, "message": "Not found"})
        
        else:
            return json_rpc_response(req_id, error={"code": -32601, "message": f"Method not found: {method}"})
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        return json_rpc_response(req_id, error={"code": -32603, "message": str(e)})

______________


app/mcp_server/tools.py
----
# app/mcp_server/tools.py

from datetime import datetime, timezone
from sqlalchemy.orm import Session
from typing import Any, Dict, List
import logging
from app.database import crud
import mcp.types as types

WIDGET_URI = "ui://widget/briefing.html"
MIME_TYPE = "text/html+skybridge"

def _tool_meta():
    """Metadata that tells ChatGPT this tool produces a widget."""
    return {
        "openai/outputTemplate": WIDGET_URI,
        "openai/toolInvocation/invoking": "Gathering your assignments...",
        "openai/toolInvocation/invoked": "Here's your briefing",
        "openai/widgetAccessible": True,
        "openai/resultCanProduceWidget": True,
        "annotations": {
            "destructiveHint": False,
            "openWorldHint": False,
            "readOnlyHint": True,
        }
    }

def _embedded_widget_resource() -> types.EmbeddedResource:
    """Returns the embedded widget resource as proper MCP type."""
    from app.mcp_server.resources import get_widget_html
    
    return types.EmbeddedResource(
        type="resource",
        resource=types.TextResourceContents(
            uri=WIDGET_URI,
            mimeType=MIME_TYPE,
            text=get_widget_html(),
            title="Daily Briefing",
        )
    )

def list_tools() -> List[Dict[str, Any]]:
    """Return list of tool definitions as dicts."""
    return [{
        "name": "briefing.get",
        "title": "Get Daily Briefing",
        "description": "Returns an interactive list of upcoming assignments",
        "inputSchema": {
            "type": "object",
            "properties": {
                "range": {
                    "type": "string",
                    "enum": ["today", "48h", "week"],
                    "default": "today",
                    "description": "Time window: 'today' (24h), '48h' (2 days), or 'week' (7 days)"
                }
            },
            "additionalProperties": False
        },
        "_meta": _tool_meta()
    }]

def _fmt_display(dt: datetime | None) -> str:
    if not dt:
        return ""
    try:
        # Use '%-I' on Unix-like systems for non-padded hour, fallback to '%I'
        return dt.strftime("%a, %b %d @ %-I:%M %p").replace('AM', 'am').replace('PM', 'pm')
    except ValueError:
        return dt.strftime("%a, %b %d @ %I:%M %p").replace('AM', 'am').replace('PM', 'pm')

def call_tool(name: str, args: dict, db: Session) -> types.CallToolResult:
    """Execute tool and return proper MCP result."""
    
    if name != "briefing.get":
        return types.CallToolResult(
            content=[types.TextContent(type="text", text=f"Unknown tool: {name}")],
            isError=True
        )
    
    window = args.get("range", "today").lower().strip()
    hours_map = {"today": 24, "48h": 48, "week": 168}
    hours = hours_map.get(window, 24)
    label_map = {"today": "today", "48h": "the next 48h", "week": "the next 7 days"}
    label = label_map.get(window, "soon")
    
    assignments = crud.upcoming_assignments(db, window_hours=hours, limit=50)
    
    # Data for the UI (_meta): The full, detailed list
    ui_items = [{
        "id": a.id, "title": a.title, "course": a.course_name, "url": a.url,
        "dueAt": a.due_at_utc.isoformat() if a.due_at_utc else None,
        "dueAtDisplay": _fmt_display(a.due_at_utc)
    } for a in assignments]
    
    # Data for the Model (structuredContent): A concise summary
    model_summary_items = [{
        "title": a.title, "course": a.course_name,
        "due": _fmt_display(a.due_at_utc)
    } for a in assignments[:5]] # Only show top 5 to the model

    # Build the final payloads
    structured = {
        "summary": {
            "count": len(assignments),
            "rangeLabel": label,
            "assignments": model_summary_items
        }
    }
    
    meta_for_ui = {
        "assignments": ui_items,
        "count": len(assignments),
        "range": window,
        "rangeLabel": label,
        "generatedAt": datetime.now(timezone.utc).isoformat()
    }
    
    widget_resource = _embedded_widget_resource()
    
    return types.CallToolResult(
        content=[types.TextContent(
            type="text",
            text=f"Found {len(assignments)} assignment(s) due {label}."
        )],
        structuredContent=structured,
        # ✅ THE FIX IS HERE: `_meta=` instead of `meta=`
        _meta={
            **_tool_meta(),
            "openai.com/widget": widget_resource.model_dump(mode="json"),
            "ui": meta_for_ui # Nest all UI-specific data here
        }
    )

______________


app/scheduler/__init__.py
----


______________


app/scheduler/scheduler.py
----
# app/scheduler/scheduler.py

from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
from sqlalchemy.orm import Session
from app.database.database import SessionLocal
from app.scheduler.sync_job import sync_schoology_data
import random
import logging
from datetime import datetime, timezone # <-- ADD THIS

_scheduler: BackgroundScheduler | None = None

def _job_wrapper():
    db: Session = SessionLocal()
    try:
        sync_schoology_data(db)
    finally:
        db.close()

def start_scheduler():
    global _scheduler
    if _scheduler:
        return _scheduler
    
    logging.info("Initializing and starting background scheduler...")
    _scheduler = BackgroundScheduler(timezone="UTC")
    # Run every 5 minutes with jitter
    _scheduler.add_job(
        _job_wrapper, 
        IntervalTrigger(minutes=5, jitter=random.randint(0, 60)),
        id="schoology_sync_job",
        replace_existing=True,
        misfire_grace_time=300 # 5 minutes grace period
    )
    _scheduler.start()
    # Trigger the first run immediately
    _scheduler.get_job('schoology_sync_job').modify(next_run_time=datetime.now(timezone.utc))
    logging.info("Scheduler started and first sync triggered.")
    return _scheduler

def stop_scheduler():
    global _scheduler
    if _scheduler and _scheduler.running:
        logging.info("Shutting down background scheduler...")
        _scheduler.shutdown()
        logging.info("Scheduler shut down.")

______________


app/scheduler/sync_job.py
----
# app/scheduler/sync_job.py

import logging
from sqlalchemy.orm import Session
from app.schoology_client.client import SchoologyClient
from app.database import crud
from datetime import datetime, timedelta, timezone

def sync_schoology_data(db: Session):
    logging.info("Starting Schoology sync job...")
    client = SchoologyClient()

    try:
        # --- 1. Sync Calendar Events ---
        now = datetime.now(timezone.utc)
        # Fetch a wide window: from 1 week ago to 60 days in the future
        start_date = now - timedelta(days=7)
        end_date = now + timedelta(days=60)
        
        start_ts = int(start_date.timestamp())
        end_ts = int(end_date.timestamp())
        
        events_data = client.get_calendar_events(start_ts=start_ts, end_ts=end_ts)
        
        if events_data:
            logging.info(f"Fetched {len(events_data)} calendar items. Upserting into database...")
            crud.upsert_calendar_events(db, events_data)
        else:
            logging.warning("No calendar items returned from Schoology client.")

        # TODO: Add calls to sync feed, grades, etc. here in the future
        
        logging.info("Sync job completed successfully.")
        return {"ok": True}

    except Exception as e:
        logging.error(f"An error occurred during the sync job: {e}", exc_info=True)
        db.rollback() # Rollback any partial changes on error
        return {"ok": False, "error": str(e)}

______________


app/database/__init__.py
----


______________


app/database/crud.py
----
# app/database/crud.py

from sqlalchemy.orm import Session
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo  # <-- KEEP THIS FOR REFERENCE, BUT NO LONGER USED IN PARSING  # noqa: F401
from app.database import models
import re

# ---- FIXED: Remove status filter since it's not being set by sync ----
def upcoming_assignments(db: Session, window_hours: int = 48, limit: int = 20):
    """
    Return assignments due within the next `window_hours`.
    """
    now = datetime.now(timezone.utc)
    end = now + timedelta(hours=window_hours)
    q = (
        db.query(models.Assignment)
        # REMOVED: .filter(models.Assignment.status == "open")
        .filter(models.Assignment.due_at_utc != None)  # noqa: E711
        .filter(models.Assignment.due_at_utc >= now)
        .filter(models.Assignment.due_at_utc <= end)
        .order_by(models.Assignment.due_at_utc.asc())
        .limit(limit)
    )
    return q.all()

def parse_html_title(html_title: str) -> str:
    """Extracts clean text from the Schoology HTML title."""
    if not html_title:
        return "Untitled"
    clean = re.sub('<.*?>', '', html_title)
    return clean.strip()

def parse_schoology_date(date_str: str) -> datetime | None:
    """
    Parses Schoology's 'YYYY-MM-DD HH:MM:SS' into UTC.

    CRITICAL FIX: Based on empirical testing, the Schoology calendar API
    returns a string that is already effectively UTC, despite appearing as
    local time. We treat the raw string as naive UTC time to avoid the
    incorrect UTC conversion offset.
    """
    if not date_str:
        return None
    dt_naive = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
    return dt_naive.replace(tzinfo=timezone.utc)


def upsert_calendar_events(db: Session, events: list[dict]):
    """
    Takes a list of raw event dicts from the SchoologyClient and updates or inserts
    them into the database, distinguishing between Assignments and Events.
    """
    for item in events:
        is_assignment_type = item.get('e_type') in ['assignment', 'assessment', 'common-assessment', 'discussion']
        
        if is_assignment_type:
            # FIX: Use content_id for link construction, as item['id'] is the calendar event ID
            assignment_id_for_link = item.get('content_id') 
            if not assignment_id_for_link:
                assignment_id_for_link = item['id'] 
                
            # Use the correct assignment ID and append '/info' for robust linking
            assignment_url = f"https://classes.esdallas.org/assignment/{assignment_id_for_link}/info"
            
            existing_assignment = db.query(models.Assignment).filter(models.Assignment.id == item['id']).first()
            
            if existing_assignment:
                # Update existing assignment
                existing_assignment.title = item.get('titleText', 'Untitled Assignment')
                existing_assignment.due_at_utc = parse_schoology_date(item.get('start'))
                existing_assignment.course_name = item.get('content_title', 'Unknown Course')
                existing_assignment.url = assignment_url
                existing_assignment.status = "open"  # SET STATUS HERE
                existing_assignment.last_seen_at_utc = datetime.now(timezone.utc)
            else:
                # Create new assignment
                new_assignment = models.Assignment(
                    id=item['id'],
                    title=item.get('titleText', 'Untitled Assignment'),
                    due_at_utc=parse_schoology_date(item.get('start')),
                    course_name=item.get('content_title', 'Unknown Course'),
                    url=assignment_url,
                    course_id=item.get('realm_id'),
                    status="open",  # SET STATUS HERE
                )
                db.add(new_assignment)
        else:
            # It's a generic event, handle it in the Event table
            existing_event = db.query(models.Event).filter(models.Event.id == item['id']).first()

            if existing_event:
                # Update existing event
                existing_event.title = item.get('titleText', 'Untitled Event')
                existing_event.start_utc = parse_schoology_date(item.get('start'))
                existing_event.end_utc = parse_schoology_date(item.get('end')) if item.get('has_end') == '1' else None
                existing_event.source = item.get('content_title', 'Unknown Source')
            else:
                # Create new event
                new_event = models.Event(
                    id=item['id'],
                    title=item.get('titleText', 'Untitled Event'),
                    start_utc=parse_schoology_date(item.get('start')),
                    end_utc=parse_schoology_date(item.get('end')) if item.get('has_end') == '1' else None,
                    source=item.get('content_title', 'Unknown Source'),
                )
                db.add(new_event)
                
    db.commit()

______________


app/database/database.py
----
from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "sqlite:///schoology.db"

engine = create_engine(
    DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)
Base = declarative_base()

def init_db():
    # pragma tuning for local SQLite
    with engine.connect() as conn:
        conn.exec_driver_sql("PRAGMA journal_mode=WAL;")
        conn.exec_driver_sql("PRAGMA synchronous=NORMAL;")
    from app.database import models  # ensure models registered
    Base.metadata.create_all(bind=engine)

# FastAPI deps pattern (used in /mcp route)
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


______________


app/database/models.py
----
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import String, Integer, DateTime, Text, Enum
from datetime import datetime, timezone
from app.database.database import Base

def utcnow():
    return datetime.now(timezone.utc)

class Assignment(Base):
    __tablename__ = "assignments"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    course_id: Mapped[int] = mapped_column(Integer, index=True)
    course_name: Mapped[str] = mapped_column(String(255))
    title: Mapped[str] = mapped_column(String(400))
    due_at_utc: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), index=True)
    url: Mapped[str | None] = mapped_column(String(1024))
    status: Mapped[str] = mapped_column(String(32), default="open")
    last_seen_at_utc: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=utcnow, index=True)

class Event(Base):
    __tablename__ = "events"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    title: Mapped[str] = mapped_column(String(400))
    start_utc: Mapped[datetime] = mapped_column(DateTime(timezone=True), index=True)
    end_utc: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    source: Mapped[str] = mapped_column(String(255))

class Update(Base):
    __tablename__ = "updates"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    author: Mapped[str] = mapped_column(String(255))
    content_html_sanitized: Mapped[str] = mapped_column(Text)
    posted_at_utc: Mapped[datetime] = mapped_column(DateTime(timezone=True), index=True)
    source: Mapped[str] = mapped_column(String(255))

class Grade(Base):
    __tablename__ = "grades"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    course_id: Mapped[int] = mapped_column(Integer, index=True)
    course_name: Mapped[str] = mapped_column(String(255))
    assignment_id: Mapped[int] = mapped_column(Integer, index=True)
    assignment_title: Mapped[str] = mapped_column(String(400))
    score_raw: Mapped[str | None] = mapped_column(String(64))
    score_pct: Mapped[float | None] = mapped_column()
    posted_at_utc: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=utcnow, index=True)

class PlannerTask(Base):
    __tablename__ = "planner_tasks"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    title: Mapped[str] = mapped_column(String(400))
    due_at_utc: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    origin: Mapped[str] = mapped_column(String(16), default="personal")  # 'schoology'|'personal'
    schoology_assignment_id: Mapped[int | None] = mapped_column(Integer, index=True)
    column: Mapped[str] = mapped_column(String(16), default="todo")  # 'todo','in_progress','done'
    priority: Mapped[int] = mapped_column(Integer, default=0)


______________


app/schoology_client/__init__.py
----


______________


app/schoology_client/client.py
----
# app/schoology_client/client.py

import os
import requests
import time
import logging
from typing import List, Dict, Any
from datetime import datetime

class SchoologyClient:
    def __init__(self):
        """Initializes the SchoologyClient with credentials from environment variables."""
        cookie = os.getenv("SCHOOLOGY_COOKIE")
        if not cookie:
            raise ValueError("SCHOOLOGY_COOKIE environment variable not set.")
        
        self.user_id = os.getenv("SCHOOLOGY_USER_ID")
        if not self.user_id:
            raise ValueError("SCHOOLOGY_USER_ID environment variable not set.")

        self.base_url = "https://classes.esdallas.org"
        self.s = requests.Session()
        self.s.headers.update({
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36",
            "Accept": "application/json, text/javascript, */*; q=0.01",
            "X-Requested-With": "XMLHttpRequest",
            "Cookie": cookie,
            "Referer": f"{self.base_url}/home"
        })

    def get_calendar_events(self, start_ts: int, end_ts: int) -> List[Dict[str, Any]]:
        """
        Fetches calendar events (assignments, events, etc.) for the user within a given timestamp range.
        """
        view_id = "2025-91" # From your captured network request
        url = f"{self.base_url}/calendar/{self.user_id}/{view_id}"
        
        params = {
            "ajax": 1,
            "start": start_ts,
            "end": end_ts,
            "_": int(time.time() * 1000)
        }
        
        # --- NEW: VERBOSE LOGGING ---
        logging.info(f"ATTEMPTING TO FETCH URL: {url}")
        logging.info(f"WITH PARAMS: {params}")
        logging.info(f"WITH HEADERS: {self.s.headers}")
        # --- END NEW LOGGING ---

        response = None # Define response here to be available in except block
        try:
            response = self.s.get(url, params=params)
            response.raise_for_status()
            
            # If we get here, the request was successful (2xx status code)
            # Now, try to parse it as JSON
            return response.json()

        except Exception as e:
            logging.error(f"AN EXCEPTION OCCURRED: {type(e).__name__} - {e}")
            
            # --- NEW: VERBOSE ERROR LOGGING ---
            if response is not None:
                logging.error(f"RESPONSE STATUS CODE: {response.status_code}")
                logging.error("--- RAW SERVER RESPONSE TEXT ---")
                # We are logging the raw text to see if it's an HTML login page
                logging.error(f"\n{response.text}\n")
                logging.error("--- END RAW SERVER RESPONSE TEXT ---")
            else:
                logging.error("Request failed before a response was received.")
            # --- END NEW ERROR LOGGING ---
        
        return []

    # --- Stubs for future implementation ---
    def get_feed_updates(self):
        return []

    def get_grades(self, course_id: int):
        return []

    def get_course_assignments(self, course_id: int):
        return []

______________


web/package.json
----
{
  "name": "schoology-copilot-web",
  "private": true,
  "scripts": {
    "build": "echo \"(stub) add React build later\""
  }
}


______________


web/briefing-widget/index.html
----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Briefing Widget</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.jsx"></script>
  </body>
</html>


______________


web/briefing-widget/package.json
----
{
  "name": "briefing-widget",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "dayjs": "^1.11.10"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.2.1",
    "vite": "^5.2.0"
  }
}


______________


web/briefing-widget/serve.py
----
# app/mcp_server/server.py

from fastapi import FastAPI, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from contextlib import asynccontextmanager
from dotenv import load_dotenv
import os
import mcp.types as types
import logging

from app.database.database import get_db, init_db
from app.scheduler.scheduler import start_scheduler, stop_scheduler
from app.mcp_server import tools, resources

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("🚀 Starting up...")
    load_dotenv()
    init_db()
    start_scheduler()
    yield
    print("👋 Shutting down...")
    stop_scheduler()

app = FastAPI(title="Schoology Co-Pilot", lifespan=lifespan)

# CORS is still important for development and communication with ChatGPT
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/healthz")
def health():
    return {"ok": True}

def json_rpc_response(request_id, result=None, error=None):
    """Helper to build JSON-RPC 2.0 responses."""
    resp = {"jsonrpc": "2.0", "id": request_id}
    if error:
        resp["error"] = error
    else:
        resp["result"] = result
    return resp

def serialize_mcp_result(result):
    """Convert MCP types to JSON-serializable dicts."""
    if isinstance(result, types.CallToolResult):
        # The .model_dump() method handles serialization correctly
        return result.model_dump(mode="json", by_alias=True)
    return result

@app.post("/mcp")
async def mcp_endpoint(request: Request, db: Session = Depends(get_db)):
    try:
        body = await request.json()
    except:
        return json_rpc_response(None, error={"code": -32700, "message": "Parse error"})
    
    method = body.get("method")
    req_id = body.get("id", -1)
    params = body.get("params", {})
    
    try:
        if method == "initialize":
            return json_rpc_response(req_id, {
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}, "resources": {}},
                "serverInfo": {"name": "schoology-copilot", "version": "0.1.0"}
            })
        
        elif method in ("tools/list", "list_tools"):
            tool_dicts = tools.list_tools()
            return json_rpc_response(req_id, {"tools": tool_dicts})
        
        elif method in ("tools/call", "call_tool"):
            name = params.get("name")
            args = params.get("arguments") or params.get("args", {})
            
            result_object = tools.call_tool(name, args, db)
            serialized = serialize_mcp_result(result_object)
            return json_rpc_response(req_id, serialized)
        
        elif method in ("resources/list", "list_resources"):
            return json_rpc_response(req_id, {"resources": resources.list_resources()})
        
        elif method in ("resources/read", "read_resource"):
            uri = params.get("uri") or (params.get("params", {})).get("uri")
            result = resources.read_resource(uri)
            if result:
                return json_rpc_response(req_id, result)
            return json_rpc_response(req_id, error={"code": 1, "message": "Not found"})
        
        else:
            return json_rpc_response(req_id, error={"code": -32601, "message": f"Method not found: {method}"})
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        return json_rpc_response(req_id, error={"code": -32603, "message": str(e)})

______________


web/briefing-widget/vite.config.js
----
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  base: './', 
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    rollupOptions: {
      output: {
        // This ensures predictable filenames with hashes for cache busting
        entryFileNames: 'assets/index-[hash].js',
        chunkFileNames: 'assets/index-[hash].js',
        assetFileNames: 'assets/index-[hash].[ext]'
      }
    }
  }
})

______________


web/briefing-widget/dist/index.html
----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Briefing Widget</title>
    <script type="module" crossorigin src="./assets/index-BMjLuB0i.js"></script>
    <link rel="stylesheet" crossorigin href="./assets/index-BqOPGF98.css">
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>


______________


web/briefing-widget/src/App.jsx
----
import React, { useState, useEffect } from 'react';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
dayjs.extend(relativeTime);

function App() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    // The official API is window.openai
    if (window.openai) {
      // Per the docs, UI-specific data is in toolResponseMetadata (_meta)
      const initialData = window.openai.toolResponseMetadata?.ui;
      if (initialData) {
        setData(initialData);
      }
      
      // It's good practice to listen for updates, though not strictly needed here
      const handleUpdate = (event) => {
        if (event.detail.globals.toolResponseMetadata) {
          setData(event.detail.globals.toolResponseMetadata.ui);
        }
      };
      
      window.addEventListener("openai:set_globals", handleUpdate);
      return () => {
        window.removeEventListener("openai:set_globals", handleUpdate);
      };

    } else {
      console.error('[Widget] window.openai is not available!');
    }
  }, []);
  
  // Read data from the correct fields based on our new backend structure
  const assignments = data?.assignments ?? [];
  const count = data?.count ?? 0;
  const rangeLabel = data?.rangeLabel || 'soon';
  const generatedAt = data?.generatedAt ? dayjs(data.generatedAt) : null;
  
  if (!data) {
    return (
      <div className="briefing-container">
        <div className="loading-state">
          <div className="spinner"></div>
          <p>Loading briefing...</p>
        </div>
      </div>
    );
  }
  
  return (
    <div className="briefing-container">
      <header>
        <h3>📚 Daily Briefing</h3>
        {generatedAt && (
          <p className="timestamp" title={generatedAt.format('YYYY-MM-DD HH:mm:ss')}>
            Updated {generatedAt.fromNow()}
          </p>
        )}
      </header>
      
      <div className="summary-card">
        <div className="count">{count}</div>
        <div className="label">
          assignment{count !== 1 ? 's' : ''} due {rangeLabel}
        </div>
      </div>
      
      {assignments.length > 0 ? (
        <ul className="assignment-list">
          {assignments.map(item => (
            <li key={item.id}>
              <a href={item.url} target="_blank" rel="noopener noreferrer">
                <div className="assignment-info">
                  <span className="title">{item.title}</span>
                  <span className="course">{item.course}</span>
                </div>
                <div className="due-date">
                  {item.dueAtDisplay}
                </div>
              </a>
            </li>
          ))}
        </ul>
      ) : (
        <div className="empty-state">
          ✨ No upcoming assignments in this timeframe!
        </div>
      )}
    </div>
  );
}

export default App;

______________


web/briefing-widget/src/index.css
----
:root {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f9fafb;
  color: #111827;
}

body {
  margin: 0;
  padding: 16px;
  box-sizing: border-box;
}

.loading-state {
    color: #6b7280;
}

.briefing-container header {
  margin-bottom: 16px;
}

.briefing-container h3 {
  margin: 0 0 4px 0;
  font-size: 1.125rem;
  font-weight: 600;
}

.briefing-container .timestamp {
  margin: 0;
  font-size: 0.75rem;
  color: #6b7280;
}

.summary-card {
  display: flex;
  align-items: baseline;
  gap: 12px;
  background-color: #ffffff;
  padding: 16px;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
  margin-bottom: 20px;
}

.summary-card .count {
  font-size: 2.25rem;
  font-weight: 700;
  line-height: 1;
  color: #1f2937;
}

.summary-card .label {
  font-size: 1rem;
  color: #4b5563;
}

.assignment-list {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.assignment-list li a {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background-color: #ffffff;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
  text-decoration: none;
  color: inherit;
  transition: background-color 0.2s ease, box-shadow 0.2s ease;
}

.assignment-list li a:hover {
    background-color: #f9fafb;
    box-shadow: 0 0 0 2px #d1d5db;
}

.assignment-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}

.assignment-info .title {
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.assignment-info .course {
  font-size: 0.875rem;
  color: #6b7280;
}

.due-date {
    font-size: 0.875rem;
    color: #4b5563;
    flex-shrink: 0;
    margin-left: 16px;
}

/* Add to existing CSS */

.loading-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  color: #6b7280;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 3px solid #e5e7eb;
  border-top-color: #3b82f6;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-bottom: 12px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.empty-state {
  text-align: center;
  padding: 32px;
  color: #6b7280;
  font-size: 0.95rem;
}


.error-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  color: #dc2626;
  text-align: center;
}

.error-icon {
  font-size: 3rem;
  margin-bottom: 12px;
}

.error-state p {
  margin: 0;
  color: #6b7280;
}

______________


web/briefing-widget/src/index.jsx
----
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)


______________